- [1. Python Introduction](#1-Python-Introduction)
- [2. ပါရာဒိုင်း ( Paradigm )](#-2-ပါရာဒိုင်း-(-Paradigm-))
- [3. OOP & PP](#-3-OOP-&-PP)
- 
- [24. Bitwise Operators](#24-bitwise-operators)
- [25. Comparison Operators (==, !=, >, <, >=, <=)](#25-comparison-operators)
- [26. Identity Operators (is, is not)](#26-identity-operators)
- [27. Membership Operators (in-not-in)](#27-membership-operators)
- [28. Logical Operators](#28-logical-operators)
- [29. Ternary Operator](#29-ternary-operator)
- [30. Assignment Operators (=)](#30-assignment-operators)
- [31. Walrus Operator (:=) 🦭](#31-walrus-operator)
- [32. Associativity အနှစ်ချုပ်](#32-associativity)
- [33. Sequence](#33-sequence)




- [1. Python Introduction](#1-Python-Introduction)
- [2. ပါရာဒိုင်း ( Paradigm )](#-2-ပါရာဒိုင်း-(-Paradigm-))
- [3. OOP & PP](#-3-OOP-&-PP)
- 
- [24. Bitwise Operators](#24-bitwise-operators)
- [25. Comparison Operators (==, !=, >, <, >=, <=)](#25-comparison-operators)
- [26. Identity Operators (is, is not)](#26-identity-operators)
- [27. Membership Operators (in-not-in)](#27-membership-operators)
- [28. Logical Operators](#28-logical-operators)
- [29. Ternary Operator](#29-ternary-operator)
- [30. Assignment Operators (=)](#30-assignment-operators)
- [31. Walrus Operator (:=) 🦭](#31-walrus-operator)
- [32. Associativity အနှစ်ချုပ်](#32-associativity)
- [33. Sequence](#33-sequence)


## 1. Python Introduction


   Python ကို  Guido van Rossum  ဖန်တီးခဲ့ပြီး 1991 တွင် စတင်မိတ်ဆက်ခဲ့ပါသည်။

2020 ထိ နှစ်ပေါင်း 30 ကျော် ပြုစုပျိုးထောင်ပေးခဲ့ပါသည်။

လက်ရှိအချိန်မှာတော့ အသက်လည်း 70 ထဲ ဝင်နေပြီဆိုတော့ အနားယူသွားပါပြီ။

Software development ကို တစ်ခေတ်ဆန်းသစ်စေခဲ့တဲ့ computer scientist တစ်ယောက်ဖြစ်ပါသည်။

---

Python ဖြင့် program ရေးသားရာတွင်

1. procedural way

2. object-orientated way 

3. functional way 

ဟူသော နည်းလမ်းသုံးမျိုး/အတွေးအမြင်သုံးမျိုးဖြင့် program ရေးသားနိုင်ပါသည်။

---

Python တွင် အရာအားလုံးသည် object များဖြစ်ကြသဖြင့် object-orientation ဟူသော အရာဝတ္ထုအမြင်ဖြင့် အလွယ်တကူတွေးပြီး program ရေးတတ်လာမှသာ သင်ကြားမှု အောင်မြင်သည်ဟု သတ်မှတ်နိုင်ပါမည်။

---

ယခုစာအုပ်တွင် အမြင်သုံးမျိုးလုံးကို မိတ်ဆက်ပေးမည်ဖြစ်ပါသည်။

---

### 2. ပါရာဒိုင်း ( Paradigm )

မူရင်းမှာ ဂရိစကားလုံးဖြစ်ပြီး ဆီလျှော်အောင် ဘာသာပြန်ပါက တွေးပုံတွေးနည်းဟူ၍ ဖြစ်ပါသည်။

program ရေးသားရာတွင် လိုအပ်ချက်ပေါ်မူတည်၍ တွေးပုံတွေးနည်းအမျိုးမျိုးဖြင့် ရေးသားကြရပါသည်။

အခြေခံအားဖြင့် Imperative Paradigm နှင့် Declarative Paradigm ဟူ၍ တွေးခေါ်နည်းနှစ်မျိုးရှိပါသည်။

---

### Imperative Paradigm

imperative ကို ဘာသာပြန်ပါက အမိန့်ပေးသည်ဟူ၍ အဓိပ္ပါယ်ရသလို 

Imperative Paradigm ဟူသော တွေးနည်းသည်လည်း "တိတိကျကျ အမိန့်ပေးပြီး ခိုင်းမည်" ဟူသော နည်းလမ်းဖြစ်ပါသည်။

---

မြင်သာအောင် ပြရပါက တံမြက်စည်း လှည်းခိုင်းသည့်အခါ အမေ့လိုမျိုး ဘေးကနေထိုင်ကြည့်ပြီး ဟိုလိုလှည်း သည်လိုလှည်းစသဖြင့် တစ်ခုမှမလွတ်စေရဘဲ ဘေးကနေ ထိန်းချုပ်ပြီး ခိုင်းတဲ့ပုံစံမျိုးကို Imperative ပုံစံလို့ ဆိုလိုတာပါ။ အမှိုက်လှည်းတဲ့အခါ လှည်းချင်သလို လှည်းခွင့်မပေးပဲ ဘယ်လိုမျိုး စနစ်တကျလှည်းရမယ်ဆိုတာမျိုး ထိုင်ပြောဖို့ကို ပိုအားသန်တာမျိုးပေါ့။

English လိုဆိုရင်တော့ How things should be done? ဖြစ်ဖို့ step-by-step instructions ပေးဖို့ကိုပဲ အဓိကထားတယ်ပေါ့။

---

### Declarative Paradigm

   Declarative ကို ဘာသာပြန်ပါက ကြေငြာသည်ဟူ၍ အဓိပ္ပါယ်ရသလို  

Declarative Paradigm ဟူသော တွေးနည်းကလည်း "လိုချင်တာပဲ ကြေငြာလိုက်မည် / လိုတာပဲ ပြောလိုက်မည်" ဟူသော နည်းလမ်းဖြစ်ပါသည်။

---

မြင်သာအောင် ဥပမာပေးရရင် 

အဖေ့လိုမျိုး သားရေ အမှိုက်ရှင်းထားလိုက်ဆိုပြီး ပစ်ထားခဲ့တာမျိုးပေါ့။ 

သူလိုချင်တာပြောလိုက်ရုံပဲရှိပြီး အမေ့လိုမျိုး ဘေးကနေ ထိုင်ကြည့်ပြီး ဆက်တိုက်ညွှန်ကြားနေတာမျိုး မရှိပါဘူး။ 

တံမြက်စည်းနဲ့ပဲလှည်းလှည်း လက်နဲ့ပဲကောက်ကောက် ကြိုက်တဲ့နည်းလမ်းကို ကြိုက်သလိုသုံးနိုင်ပြီး အမှိုက်ပြောင်နေရင် ရပြီဆိုတာမျိုး ရလဒ်ကိုပဲ ဦးစားပေးပါတယ်။

English လိုဆိုရင်တော့ result ကိုပဲ အဓိကထားတယ်ဆိုတာမျိုးပေါ့။

---

Declarative Paradigm ၏ တွေးပုံတွေးနည်းကို ရင်းနှီးလိုပါက Structure Query Language (SQL) ဖြင့် စမ်းကြည့်နိုင်ပါသည်။

SQL basic in Sololearn (28 minutes)
<https://youtu.be/Q4IUCFwVtPU>

---

Python တွင် အသုံးပြုနိုင်သော အတွေးအမြင်သုံးမျိုးအနက် ပထမနှစ်မျိုးဖြစ်သော procedural way နှင့် object-orientated way တို့သည် တိတိကျကျ အမိန့်ပေးပြီး ခိုင်းစေရသော ပုံစံဖြစ်သဖြင့် Imperative Paradigm အုပ်စုတွင် ပါဝင်ပါသည်။

တတိယမြောက်ဖြစ်သော functional way ကတော့  Declarative Paradigm အုပ်စုတွင် ပါဝင်ပါသည်။

---

### Imperative Paradigm Vs Declarative Paradigm

အမေနဲ့ အဖေလိုမျိုး 

တစ်ခုက How things should be done? ဆိုတာမျိုး step-by-step instructions ကို ဦးစားပေးပြီး 

နောက်တစ်ခုက  desired outcome / end result ကိုပဲ ဦးစားပေးတယ်ဆိုတာမျိုး မှတ်မိရင် ရပါပြီ။

---

## 3. OOP & PP

### 3.1. Object-oriented programming

object ဆိုတာက အရာဝတ္ထု ၊ oriented ဆိုတာက တွေးတာ ၊ programming ကတော့ program ရေးတာ။

အလွယ်ပြောရရင် အရာဝတ္ထုတွေဖန်တီးနေတယ်လို့ တွေးပြီး program ရေးတာမျိုးပါ။

---

### 3.2. Procedural programming 

Procedure တွေချပြီး ရေးလို့ Procedural programming လို့ခေါ်ပါတယ်။ 

---

OOP လေ့လာမယ်ဆိုရင် Procedural programming ကို အရင် လေ့လာရပါတယ်။

ဘာကြောင့်လဲဆိုတော့ Procedural programming ကို ကျွမ်းကျင်ပြီးမှသာ OOP ကို ‌အလွယ်တကူနားလည်နိုင်မှာဖြစ်လို့ပါ။

ကားသေးတောင် မမောင်းတတ်သေးပဲ ကားကြီးကို တန်းပြီး မမောင်းသင့်သလိုမျိုးပါပဲ။

ခုလိုနှိုင်းယှဥ်ပြလို့ procedural programming ကို အထင်မသေးလိုက်ပါနဲ့။

လက်ရှိသုံးနေကြရတဲ့ software အားလုံးနီးပါးကို procedural programming နဲ့ပဲ ရေးထားကြတာ ဖြစ်ပါတယ်။

OOP ဆိုတာက နောက်မှပေါက်တဲ့ ရွှေကြာပင်လေးပါ။

ဆိုလိုတာက procedure programming သိရုံနဲ့ အတော်တော်များများ ရေးနိုင်နေပါပြီ။

---

တစ်ခုရှိတာက  Python ကို တကယ်နားလည်ချင်ရင် OOP သိဖို့ လိုအပ်နေပါသေးတယ်။

ဒါကြောင့် Python သင်မယ်ဆိုရင်တော့ နှစ်မျိုးလုံးသိထားရပါမယ်။

---

### 3.3. OOP Vs Procedural programming 

procedural programming ဖြင့် သာမန် software များကို လွယ်လွယ်ကူကူ ဖန်တီးနိုင်သော်လည်း

အရမ်းရှုတ်ထွေးသော software များကိုတော့ OOP ပုံစံတွေးမှသာ ဖန်တီးနိုင်ပါသည်။

---

မြင်သာအောင် ဥပမာပေးရရင် မောင်းရတာခြင်းတူညီကြတဲ့ လေယာဉ်နဲ့ ဆိုင်ကယ်လိုမျိုးပါပဲ။

ရပ်ကွက်ထဲ နီးနီးနားနား သွားကြတဲ့အခါ ဆိုင်ကယ်ကို အသုံးပြုကြပြီး 

ကုန်းမြေတိုက်ကြီးတွေကို ဖြတ်ကျော်ပြီး မိုင်‌ပေါင်းထောင်သောင်းချီသွားချင်ရင်တော့ လေယာဉ်ပျံကို အသုံးပြုကြပါသည်။

ဟိုဘက်ရက်ကွက်ကို အလည်သွားဖို့ လေယာဉ်ကြီးမလိုအပ်သလို
တိုက်ကြီးတွေဖြတ်ကျော်ဖို့လည်း ဆိုင်ကယ်က မစွမ်းဆောင်နိုင်ပါဘူး။

procedure programming နဲ့ ရေးရမယ့်နေရာမှာ OOP နဲ့ရေးတဲ့အခါ code တွေဖောင်းပွသလို OOP နဲ့ရေးရမယ့်နေရမှာ procedure programming နဲ့ရေးရင်လည်း အရမ်းခက်ခဲသွားပါလိမ့်မယ်။

သူ့နေရာနဲ့သူပေါ့။

---

တစ်ခုသတိပေးချင်တာက programming မှာ 

အကောင်းဆုံးနည်းလမ်းဆိုတာမရှိဘဲ အသင့်တော်ဆုံးနည်းလမ်းပဲရှိပါတယ်။

ဘာမှမရေးခင် ဘာမှတွေးခင် ဒီစိတ်ထားလေးကို အရင်နှလုံးသွင်းရပါမယ်။

---

ဒီလို နှလုံးသွင်းထားသူအတွက် ငါ့နည်းက ပိုကောင်းတယ်ဆိုတာမျိုး ၊ ငါ့ programming language က ပိုကောင်းတယ်ဆိုတာမျိုး မရှိတော့ပါဘူး။

အရာရာဟာ သူ့နေရာနဲ့သူပါပဲ။

---

ဒါဟာ တရားသဘောအရ ပြောနေတာမျိုးမဟုတ်ပဲ လိုအပ်လာတဲ့အခါ ပေကပ်မနေကြပဲ အသင့်တော်ဆုံးနည်းလမ်း ၊ အသင့်တော်ဆုံး programming language ကို ရွေးတတ်ဖို့ပါ။

---

ဥပမာ ။   ။ game development လိုမျိုးဆိုရင် C++ က ဆရာကြီးဆိုတာမျိုး သိထားရမှာဖြစ်သလို data science , machine learning လိုမျိုး ခေတ်မှီပညာရပ်တွေ လေ့လာတဲ့အခါမှာလည်း Python က ပြိုင်ဖက်ကင်းတာကို သိထားရပါမယ်။

---

## 4. "Procedural Programming"

Procedural Programming ကို လေ့လာတဲ့အခါ အခြေခံအားဖြင့် ဒီလေးမျိုး သင်ရပါမယ်။

1. sequences 

2. selection (if/else)

3. iteration (loops)

4. functions

အပေါ်သုံးမျိုးကိုတော့ Control Structures / control flow လို့ ခေါ်ပါတယ်။

ရှေ့ပိုင်းမှာ Procedure တွေချပြီး ရေးလို့ Procedural programming လို့ခေါ်တယ်ဆိုပြီး ပြောထားခဲ့ပါတယ်။

Procedure ဆိုတာက လေးခုမြောက်မှာ သင်ရမယ့် function တွေ ပါပဲ။

---

#### pure procedural programming language"

C programming language ဟာ pure procedural programming language ဖြစ်လို့ procedural ပုံစံပဲတွေးပြီး ရေးသားနိုင်မှာဖြစ်ပါတယ်။

OOP ကို အသုံးမပြုနိုင်လို့ အရမ်းရှုတ်ထွေးတာမျိုးတွေ မဖန်တီးနိုင်ပါဘူး။ 

ဒါကြောင့် နောက်ပိုင်းမှာ C ကို တစ်ဆင့်မြှင့်ထားတဲ့ C++  နဲ့ နှစ်ဆင့်မြှင့်ထားတဲ့ C# ဆိုပြီး language အသစ်နှစ်မျိုးကို ထပ်မံဖန်တီးခဲ့ကြပါတယ်။

++ ဆိုတာက C programming language မှာ မူလတန်ဖိုးကို တစ်တိုးတာပါ။

---

Python, JavaScript လိုမျိုးတွေကတော့ multi-paradigm ဖြစ်လို့ အတွေးတွေကို ကန့်သတ်ထားတာမျိုး မရှိပါဘူး။

ကိုယ်တွေးနိုင်သလောက် ရေးလို့ရပါတယ်။

---

မြင်သာအောင်ပြောရရင် လေပေါ်ပျံနိုင်တယ်လို့ တွေးနိုင်ပေမယ့် မြေဆွဲအားက ကန့်သတ်ထားလို့ လေပေါ်မပျံနိုင်သလိုမျိုး တစ်ချို့ programming language တွေက ကိုယ်ရေးချင်တိုင်း ရေးလို့မရပါဘူး။ 

သံခြေကျင်းနဲ့အပြေးပြိုင်ရသလိုမျိုး အတွေးတွေမွန်းကျပ်တာမျိုး မလွတ်လပ်တာမျိုးတွေ ရှိတတ်ပါတယ်။

---

Python မှာတော့ မဖြစ်မနေလိုက်နာရမယ့် စည်းမျဉ်းမရှိပါဘူး။

လိုရမယ်ရ ထားပေးထားတဲ့ စည်းမျဉ်းတွေကိုလည်း မကြိုက်ရင် ပြင်လို့ရပါတယ်။

ဒါကြောင့် စည်းမျဉ်းတွေ ကန့်သတ်ချက်တွေကို မကြိုက်ကြသူ‌တွေက Python အမာခံ / Pythonic တွေ ဖြစ်လာကြပါတယ်။

---

ဥပဒေမရှိပဲ အေးချမ်းတဲ့ ကမ္ဘာကြီးဖြစ်ဖို့ဆိုရင် လူတိုင်းက သူတော်ကောင်းဖြစ်နေဖို့လိုအပ်သလိုမျိုး

Python ကလည်း ရေးချင်ရာရေးလို့ရနေတော့ သူရေးတာ ကိုယ်မသိ ကိုယ်ရေးတာ သူမသိမဖြစ်ကြစေဖို့ Pythonic ပုံစံတွေးတတ်ဖို့ လိုအပ်ပါတယ်။

---

## 5. Data types မိတ်ဆက်

Procedural programming နဲ့ ပတ်သတ်ပြီး မလေ့လာခင်မှာ ဘာကြောင့်လေ့လာရလဲဆိုတာနဲ့ ဘယ်လိုအယူအဆနဲ့ လေ့လာသင့်တယ်ဆိုတာကို အရင်ပြောပေးပါ့မယ်။

---

#### Procedural programming ကို ဘာကြောင့် လေ့လာရတာလဲ။

- အခုရေးနေတာ Python စာအုပ်ဖြစ်ပါတယ်။

- အခြေခံမရှိသူတွေ အလွယ်တကူ နားလည်သဘောပေါက်စေဖို့ ရေးရခြင်းဖြစ်ပါတယ်။

- Python ကို  အလွယ်တကူနားလည်ဖို့က OOP ကို နားလည်ရပါမယ်။

- OOP ကို သင်ဖို့က Procedural programming ကို ပိုင်နိုင်ဖို့ လိုအပ်ပါတယ်။

ဒါကြောင့် လေ့လာကြရတာ ဖြစ်ပါတယ်။

---

#### Procedural programming ကို ဘယ်လိုအယူအဆနဲ့ လေ့လာရမလဲ။

- imperative paradigm နဲ့ လေ့လာရပါမယ်။

- ကွန်ပြူတာကို စနစ်တကျ ခိုင်းတတ်ဖို့ သင်နေရတယ်ဆိုတာမျိုး သိထားရပါမယ်။

- သူများကို စနစ်တကျခိုင်းတတ်ချင်ရင် ကိုယ်တိုင်လည်းအသေးစိတ်သိထားဖို့ လိုအပ်ဆိုတာမျိုး တွေးထားရပါမယ်။

---

imperative paradigm မှာ အမေက တံမြက်လှည်းခိုင်းတဲ့ပုံစံမျိုးနဲ့ ဥပမာပေးခဲ့ပါတယ်။ 

အမေ့လိုမျိုး ဘေးကနေထိုင်ကြည့်ပြီး ဟိုလိုလှည်း သည်လိုလှည်းစသဖြင့် တစ်ခုမှမလွတ်စေရဘဲ ဘေးကနေ ထိန်းချုပ်ပြီး ခိုင်းတတ်ဖို့က တံမြက်စည်းလှည်းတာနဲ့ပတ်သတ်ပြီး အသေးစိတ်သိနေဖို့လိုအပ်ပါတယ်။

တံမြက်စည်းအချော ၊ တံမြက်စီးအကြမ်း ၊ တံမြက်စည်းအနု ၊ ရေစိုခံ တံမြက်စီး ၊ ရေအထိမခံတဲ့ တံမြက်စည်း ၊ ဖုန်တွေလှည်းလို့ရတဲ့ တံမြက်စည်း ၊ သစ်ရွက်လှည်းရတဲ့ တံမြက်စည်း ၊ ရေတွေလှည်းရတဲ့ တံမြက်စည်း စသဖြင့် များစွာသော တံမြက်စည်းတွေ အကြောင်းကို အသေးစိတ်သိထားဖို့ လိုအပ်သလို ကိုယ်တိုင်လှည်းခဲ့ဖူးတဲ့ အတွေ့အကြုံလည်း ရှိထားရပါမယ်။

ဒါမှပဲ သားသမီးကို မျက်စိဒေါက်ထောက်ကြည့်ထားပြီး တစ်ချက်မှ မမှားရအောင် ဘေးကနေ စောင့်ကြည့်ပြီး ထောက်ပြ သင်ပြပေးနိုင်မှာဖြစ်ပါတယ်။

တစ်ခုခုထိခိုက်တော့မယ့် အခြေအနေဖြစ်လာခဲ့ရင်လည်း ကြိုတွေးပြီး ကြိုတင်တားဆီးနိုင်မှာ ဖြစ်ပါတယ်။

---

အမေ့လို ခိုင်းတတ်ဖို့ ဒီလေးချက် လိုအပ်ပါလိမ့်မယ်။

တံမြက်စည်းအကြောင်းသိရမယ် ။

တံမြက်စည်းလှည်းတဲ့ ဖြစ်စဉ်ကို အသေးစိတ်နားလည်ထားရမယ်။  

ခိုင်းရမယ့် သားသမီးအကြောင်းသိရမယ်။ 

သင့်တော်သလို ခိုင်းတတ်ရမယ်။

---

Procedural programming ကိုလည်း imperative paradigm ဆိုတဲ့ အတွေးအခေါ် အယူအဆနဲ့ လေ့လာရမှာဖြစ်ပါတယ်။

အလွယ်ပြောရရင် အမေ့လိုမျိုး ခိုင်းတတ်ဖို့ သင်ကြရမှာဖြစ်ပါတယ်။

ဘယ်သူ့ကို ခိုင်းရမှာလဲဆိုတော့ computer ကို ခိုင်းရမှာဖြစ်ပါတယ်။

Computer ကို နားလည်ဖို့က ဒီမှာဖတ်ပါ။

Journey of computer 
<https://www.facebook.com/share/p/1AYW947NC8/>

---

တံမြက်စည်းလှည်းတဲ့ ဖြစ်စဉ်ကို နားလည်ဖို့က control flow ဆိုတဲ့ 

1. sequences, 

2. selection (if/else)

3. iteration (loops)

ဒီသုံးမျိုးကို လေ့လာကြရပါမယ်။


တံမြက်စည်းကတော့ data types တွေ ဖြစ်ပါတယ်။

တံမြက်စည်းအကြောင်းကို သေချာသိမှသာ သင့်တော်သလို အသုံးပြုတတ်မှာဖြစ်သလို data types တွေကိုလည်း သေချာအသေးစိတ်သိထားမှသာ သင့်တော်သလို အသုံးချနိုင်မှာဖြစ်ပါတယ်။

Python မှာ data types ဆယ့်ငါးခု ရှိပါတယ်။

တံမြက်စည်း ဆယ့်ငါးချောင်းပေါ့။

---

တံမြက်စည်းတွေကို အုပ်စုခွဲလိုက်ရင် အကြမ်းနဲ့အချောဆိုပြီး နှစ်မျိုးပဲရှိပါတယ်။

data types တွေမှာလည်း ကြမ်းကြမ်းတမ်းတမ်း စိတ်ကြိုက်သုံးနိုင်တဲ့ immutable data type နဲ့ သေချာလေးဂရုစိုက်ပြီး သုံးရတဲ့ mutable data type ဆိုပြီး အုပ်စုနှစ်မျိုးပဲ ရှိပါတယ်။

အုပ်စုခွဲတာတွေကလည်း ပုံစံမျိုးစုံရှိပြီး အသုံးပြုချိန်သင်မှသာ ပိုပြီးနားလည်နိုင်မှာ ဖြစ်လို့ data types ဆယ့်ငါးမျိုးကိုပဲ အရင်လေ့လာကြပါမယ်။

---

ဒါကတော့ data types ဆယ့်ငါးခုရဲ့ အတိုကောက်အမည်တွေ ဖြစ်ကြပါတယ်။

1. str
2. int
3. float
4. complex
5. list
6. tuple
7. range
8. dict
9. set
10. frozenset
11. bool
12. bytes
13. bytearray
14. memory view
15. NoneType        

---

သားသမီးကို တံမြက်စီးယူခိုင်းတဲ့အခါ လိုချင်တဲ့ တံမြက်စည်းအမျိုးအစားမရှိဘူးဆိုတာမျိုး ဖြစ်လာနိုင်ပါတယ်။

ဆယ့်ငါးခုမြောက် အမျိုးအစားဖြစ်တဲ့ None ဆိုတာကလည်း မရှိဘူးဆိုတဲ့အကြောင်းကို အသိပေးဖို့သုံးတဲ့ အမှတ်အသားပါ။

တန်ဖိုး မရှိကြောင်းဖော်ပြဖို့ zero ကို သုံးကြသလိုမျိုးပါပဲ။

NoneType ကိုလည်း data type မရှိကြောင်းဖော်ပြနိုင်ဖို့ ဖန်တီးပေးထားပါတယ်။

---

ဆိုင်မှာရောင်းတဲ့ တံမြက်စည်းအမျိုးအစားထဲမှာ လေပေါ်ပျံနိုင်တဲ့ တံမြက်စည်းမပါဝင်ပါဘူး။

အပြင်လောကမှာ ဟယ်ရီပေါ်တာဖြစ်ချင်တယ်လို့ စိတ်ကူးနိုင်ပေမယ့် တံမြက်စည်းမရှိလို့ ဖြစ်ခွင့်မရနိုင်ပါဘူး။

Python မှာတော့ စိတ်ကူးနိုင်သလောက် ဖန်တီးနိုင်ပါတယ်။

ဆိုလိုတာက data အမျိုးအစား ဆယ့်ငါးခုအပြင်ကို ကိုယ့်ဘာသာလည်း ထပ်ဖန်တီးလို့ ရတယ်ဆိုတာပါပဲ။

---

မြင်သာအောင် ပြောရရင် 

ကိန်းပြည့်အမျိုးအစား data ကို အသုံးပြုပြီး တစ်ပေါင်နဲ့ တစ်ကီလိုကို ပေါင်းခဲ့ရင် 

1 + 1 ဖြစ်လို့ အဖြေ 2 ရပါမယ်။

တကယ့်လက်တွေ့မှာက 1.45 ကီလို  ဒါမှမဟုတ် 3.2 ပေါင်ဖြစ်မှသာ မှန်ကန်မှာ ဖြစ်ပါတယ်။

ပေါင်ကို 2.2 နဲ့ စားပြီး ကီလိုပြောင်းပြီး ပေါင်းတာပဲဖြစ်ဖြစ်
1lb + 1kg = 0.45kg + 1 kg = 1.45 kg

ကီလိုကို 2.2 နဲ့ မြှောက်ပြီး ပေါင်ပြောင်းပြီး ပေါင်းတာပဲဖြစ်ဖြစ်
1lb + 1kg = 1lb + 2.2lb = 3.2 lb

နောက်ကွယ်ကနေ စီစဉ်‌ပေးရမှာ ဖြစ်ပါတယ်။

အလေးချိန်နဲ့ပတ်သတ်တဲ့ data အမျိုးအစားမရှိလို့ ကီလိုဂရမ်နဲ့ ပေါင်တွေ လိုအပ်လာခဲ့ရင် ကိုယ့်ဘာသာ စီစဉ်ဖန်တီးလိုက်လို့ ရပါတယ်။ 

---

ဒီ data ဆယ့်ငါးခုက လိုအပ်ရင် အလွယ်တကူယူသုံးနိုင်စေဖို့ Python က ဖန်တီးပေးထားတာဖြစ်ပြီး download ဆွဲတဲ့အခါ Python နဲ့အတူ တစ်ခါတည်း ပါလာမှာ ဖြစ်ပါတယ်။

Python ထဲမှာ မူလတည်းက ပါလာတဲ့အရာတွေကို built-in လို့ ခေါ်ပါတယ်။

ဒါကြောင့် ဒီ data အမျိုးအစားဆယ့်ငါးမျိုးကို ** built-in data types ** လို့ ခေါ်ကြပါတယ်။

---

#### custom data type

ပေါင်နဲ့ ကီလိုဂရမ်လိုမျိုး customer ရဲ့ လိုအပ်ချက်အရ အသစ်ဖန်တီးလိုက်ရတဲ့ data အမျိုးအစားတွေကိုတော့ custom data type လို့ခေါ်ကြပါတယ်။

---

စာဖတ်ပြီးတဲ့အခါ ဒီမေးခွန်းတွေဖြေပေးပါ။

1. ခိုင်းခံရမယ့် သားသမီး‌နေရာမှာ  computer ဖြစ်ပြီး ၊ တံမြက်စည်းတွေက data types ဆယ့်ငါးခု ဖြစ်ကြပါတယ်။ ခိုင်းမယ့် အမေ့နေရာမှာ ဘယ်သူဖြစ်မှာလဲ။

2. သုံးတဲ့အခါ ဂရုစိုက်ဖို့လိုအပ်တာက ဘယ်လို data အမျိုးအစားတွေလဲ။

3. Python မှာ built-in data types ဘယ်နှစ်ခုရှိလဲ။

4. custom data type ကို ဘယ်သူဖန်တီးရမှာလဲ။

5. data types တွေကို တံမြက်စည်းလို့ ယူဆခဲ့ရင် None ဆိုတာက တံမြက်စည်း ရှိတာလား / မရှိတာလား။

---

## 6. Usage of data types 

တံမြက်စည်းမလှည်းခင် တံမြက်စည်းတွေအကြောင်းကို သိထားရပါမယ်။

ဒါမှသာ သင့်တော်မယ့် တံမြက်စည်းအမျိုးအစားကို ရွေးချယ်တတ်မှာဖြစ်ပါတယ်။

အိမ်ထဲက ဖုန်တွေလှည်းမယ်ဆိုရင် အမျှင်လေးတွေအများကြီးပါတဲ့ တံမြက်စည်းအနုကို သုံးရမှာဖြစ်ပြီး 

အိမ်ပြင်က သစ်ရွက်တွေကို လှည်းတဲ့အခါ 

ဖုန်မထချင်ဘဲ သစ်ရွက်ပဲ လှည်းချင်တယ်ဆိုရင်တော့ ခပ်ကျဲကျဲ တံမြက်စည်းအကြမ်းကို သုံးရမှာဖြစ်ပါတယ်။

အလုပ်မြန်မြန်ပြီးချင်ရင်တော့ အရိုးရှည်တဲ့ တံမြက်စည်းကို ရွေးရမှာဖြစ်ပါတယ်။

---

program ရေးတဲ့အခါမှာလည်း 

1. စာတွေနဲ့ ပတ်သတ်လာရင် str အမျိုးအစား data type ကို အသုံးပြုရပါတယ်။

2. ကိန်းဂဏန်းတွေနဲ့ပတ်သတ်လာရင်တော့ int, float, complex ကို အသုံးပြုနိုင်ပါတယ်။

3. အမှတ်စာရင်း ၊ အမည်စာရင်း အစရှိသဖြင့် data အစုအဝေးဖန်တီးချင်ရင် list , tuple ကို သုံးရပါတယ်။

4. အရေအတွက်များပြားတဲ့ ကိန်းဂဏန်းအစီအစဉ်တွေ ဖန်တီးချင်ရင်တော့ range ကို အသုံးပြုရပါတယ်။

5. English - မြန်မာ အဘိဓါန် ( dictionary ) မှာ  apple နဲ့ ပန်းသီးဆိုတဲ့ တန်ဖိုးနှစ်ခုကို တွဲပြီးသိမ်းထားသလိုမျိုး 

တန်ဖိုးနှစ်ခုတွဲပြီး သိမ်းချင်ရင် dict ကို အသုံးပြုနိုင်ပါတယ်။

6. ထပ်နေတဲ့တန်ဖိုးတွေမပါဝင်တဲ့  data အစုအဝေး ဖန်တီးဖို့ လိုအပ်လာခဲ့ရင် set, frozen set ကို အသုံးပြုနိုင်ပါတယ်။ 

လေးတန်းမှာ သင်ခဲ့ရတဲ့ union, intersection,  superset, subset စတဲ့ set theory တွေနဲ့ ဖြေရှင်းတဲ့အခါ သုံးပါတယ်။

7. True, Flase ဆိုတဲ့ Boolean တန်ဖိုးတွေ ဖန်တီးချင်ရင် bool ကို သုံးပါတယ်။

8. 10100011 စတဲ့  binary data တွေနဲ့ ပတ်သတ်ပြီး
 ဖန်တီးချင်ရင်တော့ bytes, bytearray  စတာတွေကို အသုံးပြုနိုင်ပါတယ်။

memory address ကို copy မကူးပဲ တိုက်ရိုက်ပြင်ချင်ရင်တော့ memory view ကို အသုံးပြုနိုင်ပါတယ်။

9. တံမြက်စည်းမရှိကြောင်း အသိပေးချင်ရင်တော့ None ကို သုံးပါတယ်။

---
 
အောက်ပါ ဆယ့်ငါးခုကို ကြည့်ပြီး ဘယ်အမည်တွေကို ဘာအတွက်သုံးလည်း ပြန်တွေးပါ။

1. str
2. int
3. float
4. complex
5. list
6. tuple
7. range
8. dict
9. set
10. frozenset
11. bool
12. bytes
13. bytearray
14. memory view
15. NoneType        

---

တကယ်တော့ အမည်အပြည့်အစုံကို သိထားခဲ့ရင် တကူးတက မှတ်ထားစရာမလိုတော့ပါဘူး။

အမည်တွေကိုယ်တိုင်က အဖြေတွေပါပဲ။

1. str ( character string ) ( စာကြောင်း / စာတန်း )

2. int ( integer ) ( ကိန်းပြည့် )

3. float ( floating-point number ) ( ဒဿမကိန်း )

4. complex ( complex number ) 

5. list ( list ) သာမန်စာရင်း

6. tuple ( tuple ) စာရင်းသေ / ပြင်လို့မရသော စာရင်း

7. range ( range of numbers )

8. dict ( dictionary )

9. set ( set ) အစုအဝေး

10. frozenset ( ပြင်မရသော အစုအဝေး )

11. bool ( Boolean )

12. bytes ( 8 bits ရှိလို့  byte လို့ ခေါ်ပါတယ်။ )

13. bytearray ( byte အစုအဝေး )

14. memory view ( memory ကို တိုက်ရိုက်ပြ )

15. NoneType ( data type/ callable type စသဖြင့် Type မရှိတာကို ဆိုလိုပါသည်။ )

---

မေးခွန်းတွေဖြေပြီး comment မှာ ရေးထားပေးပါ။

1. ပြန်ပြင်ဖို့ မရည်ရွယ်ထားသော စာရင်းသေတစ်ခုဖန်တီးလိုပါက မည်သည့် data အမျိုးအစားကို အသုံးပြုရမည်နည်း။
အလွယ်တကူ ပြန်လည်ပြင်ဆင်ဖို့ ရည်ရွယ်ထားပါက မည်သည့် data အမျိုးအစားကို အသုံးပြုရမည်နည်း။

2.  2025 Python course ၏ video lesson class တွင် သင်တန်းသား 50 ရှိပြီး စာအုပ် group တွင် 70 ရှိပါသည်။
video lesson class မှ သင်တန်းသား နှစ်ဆယ်သည် စာအုပ်လည်း ဝယ်ထားပါသည်။
စုစုပေါင်း သင်တန်းသားအရေအတွက် မည်မျှရှိသနည်း။
အထက်ပါမေးခွန်းကဲ့သို့ set theory ကို အသုံးပြုပြီး ဖြေရှင်းရန်လိုအပ်လာပါက မည်သည့် data အမျိုးအစားကို ရွေးချယ်ရမည်နည်း။

3. သုည နှင့် တစ်သန်း ကြားတွင်ရှိသော မကိန်းနံပါတ်များကို အစီအစဉ်တကျ ထုတ်ပေးရန် လိုအပ်လာပါက မည့်သည့် data အမျိုးအစားကို ရွေးချယ်သင့်သနည်း။

4. ဆယ်နှစ် ၊ ဆယ့်ငါးနှစ် စသဖြင့် သာမန်ပေါင်းနှုတ်ပြုလုပ်ရန်သာ လိုအပ်ပါက မည်သည့် data အမျိုးအစားကို ရွေးချယ်သင့်သနည်း။

5. How to represent complex number 9+10i in the 2D complex plane?
အထက်ပါမေးခွန်းကဲ့သို့ complex number ကို အသုံးပြုပြီး ဖြေရှင်းရန်လိုအပ်လာပါက မည်သည့် data အမျိုးအစားကို ရွေးချယ်ရမည်နည်း။

6. byte တစ်ခု ဖန်တီးလိုပါက မည်သည့် data အမျိုးအစားကို အသုံးပြုရမည်နည်း။
byte အများကြီး ဖန်တီးလိုပါက မည်သည့် data အမျိုးအစားကို အသုံးပြုရမည်နည်း။

7. negative words, positive words ကဲ့သို့သော အနှုတ်သဘောဆောင်သောစကားလုံးများနှင့် အပြုသဘောဆောင်သော စကားလုံးများကို ခွဲခြားရန်လိုအပ်လာပါက မည်သည့် data အမျိုးအစားကို အသုံးပြုရမည်နည်း။

---

## 7. Notations 

တံမြက်စည်းအမျိုးအစားတွေကို သိသွားပြီးတဲ့အခါ တံမြက်စည်းကိုင်ပြီး အမှိုက်လှည်းကြရမယ့်အချိန် ရောက်လာသလိုမျိုး

program ရေးရာမှာ အသုံးပြုကြရမယ့် data အမျိုးအစားတွေကို သိရှိပြီးသွားကြတဲ့အခါမှာ data type တွေကို ကိုင်တွယ်ကြရပါမယ်။

တစ်ခုရှိတာက တံမြက်စည်းကို ကျွန်တော်တို့ ကိုင်တွယ်ရမှာမဟုတ်ပဲ ကိုင်ခိုင်းရမယ့် မိခင်နေရာမှာ သရုပ်ဆောင်ကြရမှာဖြစ်လို့ မိခင်က သားသမီးကို ဒီလိုတံမြက်စည်းဆိုရင် ဒီလက်နဲ့ ဒီလိုကိုင်ရမယ်ဆိုတာမျိုး ပြောဖို့ လိုအပ်သလိုမျိုး ကျွန်တော်တို့ကလည်း ကွန်ပြူတာကို ဒီလို data အမျိုးအစားဆိုရင်  memory ( RAM ) ထဲမှာ ဒီလိုသိမ်းထားရမယ်ဆိုတာမျိုး ပြောပြ‌ပေးဖို့ လိုအပ်ပါတယ်။

built-in data အမျိုးအစား ဆယ့်ငါးခုက Python ထဲမှာ ဖန်တီးထားပြီးသားဖြစ်လို့ တံမြက်စည်းကိုင်နည်းသင်သလိုမျိုး အသေးစိတ် ပြောပေးစရာတော့ မလိုအပ်ပါဘူး။

သတ်မှတ်ထားတဲ့ အမှတ်အသားတစ်ခုခုကို သုံးလိုက်ရုံနဲ့ Python က computer ကို ကျွန်တော်တို့အစား ပြောပြပေးပါလိမ့်မယ်။

---

data တွေကို " ဘယ်လို store လုပ်ရမလဲ / hold လုပ်ရမလဲ " ကွန်ပြူတာကို ပြောပြဖို့အတွက် နည်းလမ်းနှစ်ခု သတ်မှတ်ပေးထားပါတယ်။

ပထမနည်းက သင်္ကေတအမှတ်အသားနဲ့ ပြောပြတာဖြစ်ပြီး ဒုတိယနည်းကတော့ အမည်အမှတ်အသားနဲ့ပြောပြတာ ဖြစ်ပါတယ်။

---

သင်္ကေတအမှတ်အသားနဲ့ ပြောပြတာမသင်ခင် သင်္ကေတအမည်တွေကို အရင်မိတ်ဆက်ပေးပါ့မယ်။

---

#### Names of notations

##### 1. quotation marks   
 
မျက်လုံးကို ကာပေးတဲ့ မျက်တောင်နဲ့တူလို့ မျက်တောင်အမှတ်အသားလို့ ခေါ်ပါတယ်။       

နှစ်ခုတွဲသုံးလေ့ရှိပြီး ဘယ်ဘက်ခြမ်းကို opened quotation အမှတ်အသားလို့ ခေါ်ကြပြီး ညာဘက်ခြမ်းက တစ်ခုကိုတော့ closed  quotation အမှတ်အသားလို့ ခေါ်ကြပါတယ်။

အလွယ်မှတ်ရရင် မျက်တောင်အဖွင့်အပိတ်ပေါ့။

###### single quotes   --->   '  ... '

တစ်ခုတည်းဆိုရင် single quotes အမှတ်အသားလို့ ခေါ်ပါတယ်။

###### double quotes   --->   " ... "

နှစ်ခုပူးပါတဲ့ quote ဆိုရင်တော့ double quotes အမှတ်အသားလို့ ခေါ်ပါတယ်။

###### triple quotes   --->   """ ... """,     ''' ... '''

single quotes သုံးခုပူး ဒါမှမဟုတ် double quotes သုံးခုပူးထားခဲ့ရင် triple quotes အမှတ်အသားလို့ ခေါ်ကြပါတယ်။

single က တစ် ၊ double က နှစ် ၊ triple ကတော့ သုံးကို ပြောတာပါ။

---

##### 2. decimal notation   --->   .

English လို dot ဒါမှမဟုတ် point လို့ခေါ်နိုင်တဲ့ ဒီအစက်‌လေးကိုတော့ decimal အမှတ်အသားအဖြစ် သုံးကြပါတယ်။

ရုရှားလိုမျိုး အချို့ ဥရောပနိုင်ငံတွေကတော့ comma ကိုလည်း decimal အမှတ်အသားအဖြစ် သုံးကြပါတယ်။

Python မှာတော့ decimal အမှတ်အသားအဖြစ် decimal point တစ်မျိုးတည်းကိုပဲ အသုံးပြုပါတယ်။ 

ကော်မာအမှတ်အသားကိုတော့ အခြားနေရာမှာ အသုံးပြုထားပါတယ်။

###### decimal fractions    --->   0.3           

decimal point ရဲ့ ညာဘက်ခြမ်းကို decimal fractions လို့ ခေါ်ပါတယ်။ 

decimal ဆိုတာက ဆယ်လီစိတ်စနစ်ဖြစ်ပါတယ်။ တစ်ဆယ်ပဲထားပါတော့။

fractions က မြန်မာလို အပိုင်းဂဏန်းပါ။

decimal fractions ကြတော့ ဆယ်ပိုင်းပိုင်းထားသော အစိတ်အပိုင်းပေါ့။

---

0.3 ဆိုရင် ဆယ်ပိုင်း သုံးပိုင်းဖြစ်ပါမယ်။

တစ်နည်းအဖြင့် သုံးကို တစ်ဆယ် တစ်ထပ်နဲ့ စားထားတယ်လို့ ရေးထားတာပါ။ 

0.3   --->   3 / 10 

ညာဘက်ကပ်ရပ် ပထမဆုံး တစ်ခုက တစ်ဆယ်တစ်ထပ်နဲ့စားထားတာဖြစ်ပြီး နှစ်ခုမြောက်ဆိုရင်တော့ တစ်ဆယ် နှစ်ထပ်နဲ့ စားထားတယ်လို့ ဆိုလိုတာဖြစ်ပါတယ်။ 

0.03    --->   3 / 100

ဆယ်ခုမြောက် ဆယ်နေရာမြောက်ဆိုရင်တော့ တစ်ဆယ် 10 ထပ်နဲ့ စားထားတယ်လို့ ဆိုလိုတာဖြစ်ပါတယ်။

0 . 000 000 000 3   --->   ( 3 / 1e10 )

( e ဆိုတာက exponent ဖြစ်ပါတယ်။ e10 က တစ်ဆယ် ဆယ်ထပ်ပါ။  )

ဒါက decimal fractions  ရဲ့ အလုပ်လုပ်ပုံပါ။

---
   
##### 3. j နဲ့  i    --->    root  -1

သင်္ချာမှာ complex number ဖန်တီးဖို့ i ကို သုံးကြပါတယ်။

i က root -1 ကို ကိုယ်စားပြုပါတယ်။

python မှာတော့ complex number ဖန်တီးဖို့အတွက် i ကို အသုံးမပြုထားပဲ  j ဆိုပြီး ပြောင်းလဲ အသုံးပြုထားပါတယ်။

i ကိုတော့ တစ်ခြားနေရာမှာ အသုံးပြုထားပါတယ်။

###### How to represent complex number 9+10i in the 2D complex plane?

အပေါ်က‌ မေးခွန်းလိုမျိုးတွေ ဖြေရှင်းဖို့ computer ကို complex number တွေ ဖန်တီးခိုင်းဖို့ လိုအပ်လာခဲ့ရင်  9 + 10i အစား 9 + 10j လို့ ပြောင်းလဲရေးသားဖို့ လိုအပ်ပါတယ်။

---

##### 4. square brackets      --->   [ ]

square က လေးထောင့်ပါ။

bracket က ကွင်းခတ်တာကို ပြောတာပါ။

square brackets ဆိုတော့ လေးထာင့်ကွင်းပေါ့။

---

##### 5. round brackets       --->   ( )

round က မြန်မာလို လုံးဝန်းတာဖြစ်ပြီး round brackets ကတော့ လုံးဝန်းသော ကွင်းပေါ့။

လက်သည်းနဲ့တူလို့ လက်သဲကွင်း ၊ ဝိုက်ပြီးဆွဲရတာဖြစ်လို့ ဝိုက်ကွင်း စသဖြင့် ခေါ်ကြပါတယ်။

brackets, parenthesis ဆိုပြီးလည်း ခေါ်ကြပါသေးတယ်။
      
---                        
                    
##### 6. curley brackets      --->   { }

curley က တွန့်လိပ်တာကို ပြောတာပါ။

curley bracket ဆိုတော့ တွန့်ကွင်းပေါ။

သူ့ကို  braces လို့လည်း ခေါ်ကြပါသေးတယ်။
                               
---

Computer memory ထဲမှာ data သိမ်းတာလိုမျိုးတွေက တံမြက်စည်းကိုင်သလိုမျိုး ရိုးရှင်းနေတာမဟုတ်လို့ အသေးစိတ် သိချင်ရင်တော့ ဟားဗတ်တက္ကသိုလ်က ပါမောက္ခတွေ သင်ထားတဲ့ computer science သင်ရိုးရှိပါတယ်။

မြန်မာစာတမ်းထိုးလည်း ပါပါတယ်။

စာဖတ်ပြီး ထိုင်ကြည့်နေရုံနဲ့ အလွယ်တကူ နားလည်နိုင်ပါတယ်။

https://tinyurl.com/CS50xBA-CS50T

---

Exercises အနေနဲ့ကတော့

notations ဆိုတဲ့ အမှတ်အသားအမည်တွေကို အလွတ်ကျက်ထားရပါမယ်။

မြန်မာလိုလည်း မှတ်ထားရပါမယ်။

ဒါတွေက ဗဟုသုတဖြစ်လို့ question မရှိပါဘူး။

---


## 8. Creating built-in data types 

##### (A) Creating built-in data types with notation

##### (B) Creating built-in data types with name

---

##### (A) Creating built-in data types with notation 

built-in data types တွေကို သင်္ကေတတွေနဲ့ ဖန်တီးတာကို လေ့လာကြပါမယ်။

built-in data type ဆိုတာက ဖန်တီးပြီးသား data အမျိုးအစားတွေကို ပြောတာဖြစ်ပြီး ဒါကိုမှ ဖန်တီးတယ်လို့ ထပ်ပြီးသုံးရတာက အိမ်မှာရှိပြီးသား တံမြက်စည်းအနေနဲ့ဆိုရင် ယူသုံးလိုက်ရုံပဲရှိပေမယ့် ကွန်ပြူတာကြတော့ ဟယ်ရီပေါ်တာရဲ့ တံမြက်စည်းလိုမျိုး ဂါထာရွတ်မှ လေထဲက ထွက်လာမှာပါ။

ဂါထာတော့ ဖန်တီးထားပေမယ့် တံမြက်စည်းတော့ မဖန်တီးရသေးသလိုမျိုးပါပဲ။

ဒီမှာလည်း built-in ဆိုတာက data အမျိုးအစားများ ဖန်တီးပေးထားခြင်းကိုသာ ဆိုလိုတာဖြစ်ပြီး data ကို ဖန်တီးပေးထားတာမျိုးတော့ မဟုတ်ပါဘူး။

---

###### စကားပြန်

သင်္ကေတတွေနဲ့ ဖန်တီးကြတဲ့အခါ သင်္ကေတတွေကို Python နားလည်နိုင်တဲ့ အချက်ပြမှုတွေလို့ ယူဆနိုင်ပါတယ်။

ဘာကြောင့် computer နားလည်နိုင်တဲ့ အချက်ပြမှုတွေလို့ မပြောရလဲဆိုတော့ ကျွန်တော်တို့ရေးနေတဲ့ code တွေကို computer က နားမလည်ပါဘူး။

ခလုတ်နှိပ်ရင် လျှပ်စစ်စီးမှာဖြစ်ပြီး လျှပ်စစ်စီးရင် မီးလင်းမယ်ဆိုတာမျိုး မီးခလုတ်အဆင့်ပါပဲ။

program ရေးတယ်ဆိုတာက computer ကို ခိုင်းလိုက်တာဖြစ်ပေမယ့် computer က လူစကားနားမလည်လို့ စကားပြန်သဘောမျိုး ဝင်ပြောပေးဖို့ လိုအပ်တဲ့အတွက် Python ကို ကြားခံအဖြစ်သုံးရာကနေ Python ကို သင်လာကြရတာဖြစ်ပါတယ်။

---

###### high level နှင့် low level

တကယ်တော့ Python နဲ့ computer ကြားမှာလည်း တစ်ခြားစကားပြန်တွေ ၊ ဘာသာပြန်စက်တွေ အဆင့်ဆင့် ရှိကြပါသေးတယ်။

ကျွန်တော်တို့ ရေးလိုက်တာကို ကွန်ပြူတာနားလည်ဖို့ အဆင့်ခြောက်ဆင့်ရှိတယ်ဆိုပါစို့။

ကြားမှာ စကားပြန်ခြောက်‌ယောက်ရှိသလိုမျိုး ခြောက်ဆင့်မြောက်ထပ်ထားတဲ့အဆင့်ကိုတော့ high level လို့ ခေါ်ပြီး နှစ်ဆင့်မြောက်လိုမျိုး ကြားခံအဆင့်တွေ နည်းနည်းပဲ ထပ်ထားတာကိုတော့ low level လို့ ခေါ်ကြပါတယ်။

---

###### Time Complexity

ကြားခံဘာသာပြန်ရတဲ့အဆင့်တွေများလာလေ အချိန်ကြာလေဖြစ်ပြီး ကြားခံနည်းလေ အလုပ်တွင်လေဖြစ်လို့ low level programming language ဖြစ်တဲ့ C programming language လိုမျိုးတွေကို ကွန်ပြူတာကို တိုက်ရိုက်ထိန်းချုပ်ဖို့အတွက် အသုံးပြုကြပါတယ်။

တကယ်တော့ high level သုံးလို့ အချိန်အများကြီး ပိုကြာသွားတာမျိုးတော့မဟုတ်ပါဘူး။

တစ်စက္ကန့်ရဲ့ တစ်သန်းပုံတစ်ပုံ ဒါမှမဟုတ် တစ်ထောင်ပုံတစ်ပုံ ဒါမျိုးလောက်ပါပဲ။

ဒါပေမယ့်လည်း အသံထက်မြန်တဲ့နှုန်းနဲ့ ပျံနေကြတဲ့ ဒုံးကျည်တွေကြတော့ သိသာပါတယ်။

Mach 3 နဲ့ ပျံသန်းနေတဲ့ ဒုံးကျည်ဟာ 1 second နောက်ကျခဲ့ရင် ပစ်မှတ်နဲ့ 1029 မီတာ လွဲချော်သွားမှာ ဖြစ်ပါတယ်။

တစ်စက္ကန့်ရဲ့ တစ်ထောင်ပုံတစ်ပုံပဲဆိုရင်တောင် တစ်မီတာတော့ လွဲချော်နေဦးမှာဖြစ်ပါတယ်။

အာကာသယဉ်တွေကြတော့ ဂြိုလ်ပတ်လမ်းတွေနဲ့ တွက်ချက်ကြရတော့ ပိုဆိုးပါတယ်။

မိုင်ထောင်ချီဝေးသွားတာမျိုးထိတောင် ဖြစ်သွားစေနိုင်ပါတယ်။

---

နောက်တစ်ခုရှိတာက တစ်သန်းပုံတစ်ပုံပဲ နှေးရင်တောင် အလုပ်တစ်သန်းလုပ်ရမယ်ဆိုရင်တော့ တစ်စက္ကန့်နောက်ကျပါလိမ့်မယ်။ 

ကြုံခဲ့ရတဲ့အဖြစ်အပျက်တစ်ခုကို ပြောရရင် excel file ထဲက data တွေကို ကိုယ့်ဘာသာ စစ်ထုတ်တဲ့အခါ တစ်နာရီနီးပါးကြာခဲ့ပြီး C programming နဲ့ compile လုပ်ထားတဲ့ pandas ကို သုံးတဲ့အခါမှာတော့ ချက်ချင်းအဖြေထွက်ပါတယ်။

ဒါကြောင့် Program ရေးကြတဲ့အခါ 1 micro seconds လို့ခေါ်တဲ့ တစ်စက္ကန့်ရဲ့ တစ်သန်းပုံတစ်ပုံလေးပဲ ပိုမြန်မယ်ဆိုရင်တောင် ပိုမြန်ပါစေဆိုတာမျိုး ကြံဖန်ပြီး ဖန်တီးကြရသလို မရရအောင်လည်း ကြံဖန်ရေးကြပါတယ်။

Python မှာဆိုရင်တော့ list comprehension နဲ့  lazy evaluation လုပ်နိုင်တဲ့ iterator လိုမျိုးတွေ သုံးကြသလို သူ့ထက်ရှုတ်တာတွေလည်း သုံးကြပါသေးတယ်။ Pandas လိုမျိုး အသင့်သုံး module တွေကိုလည်း C programming နဲ့ compile လုပ်ထားလေ့ရှိကြပါတယ်။

နည်းလမ်းပေါင်းစုံနဲ့ အဆင့်ကျော်ပြီး ကြံဖန်ရေးကြတာတွေကြောင့် သင်တန်းမှာ အရမ်းတော်ခဲ့ရင်တောင် စီနီယာတွေ ရေးထားကြတဲ့ code တွေကို နားမလည်နိုင်ဖြစ်ကြရပါတယ်။


ဒါတွေကြတော့ ရေးနိုင်ပြီဆိုမှသာ လေ့လာသင့်တာဖြစ်လို့ algorithms လိုမျိုး နောက်ပိုင်းစာအုပ်တွေမှပဲ ထည့်ရေးပေးပါ့မယ်။

လက်ရှိ သင်ခန်းစာနဲ့ မဆိုင်တဲ့ ဗဟုသုတတွေဖြစ်သလို နောက်လည်း သင်ကြရမှာဖြစ်လို့ data type ဖန်တီးတာကိုပဲ ဆက်ပြီးလေ့လာကြပါမယ်။

---

##### 1. str   --->   ' ', " ", ''' ''', """ """ 

စာတွေကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ quotation marks တွေကို သုံးပါတယ်။

သားသမီးကို တံမြက်စည်းအမျိုးအစားတစ်ခုခုကို ယူခိုင်း / ကိုင်ခိုင်းသလိုမျိုး ကွန်ပြူတာရဲ့ memory ထဲမှာ စာအမျိုးအစား data တစ်ခုကို hold လုပ်ထားစေချင်ရင် quotation mark သင်္ကေတလေးခုထဲက တစ်ခုခုကို သုံးလိုက်ရုံပါပဲ။

သင်္ကေတပဲသုံးထားခဲ့ရင် စာတန်ဖိုး အလွတ်တစ်ခုကို RAM ဆိုတဲ့ memory ပေါ်မှာ ဖန်တီးခိုင်းတယ်လို့ Python က နားလည်သွားမှာဖြစ်ပြီး သူနားလည်တဲ့အတိုင်း computer ကို အလုပ်လုပ်ခိုင်းမှာ ဖြစ်ပါတယ်။

အလွတ်မဟုတ်ပဲ တန်ဖိုးတွေပါထည့်ပေးလိုက်ချင်ရင်တော့ open quotation mark နဲ့ close quotation mark ကြားထဲမှာ ထည့်လိုတဲ့ စာတွေ ရေးပေးလိုက်ရမှာ ဖြစ်ပါတယ်။

I go to school . ဆိုတဲ့ 

တန်ဖိုးတွေပါဝင်တဲ့ စာကြောင်းတစ်ခုကို ဖန်တီးချင်တယ်ဆိုပါစို့။ 

ဒီ ပုံစံလေးခုထဲက ကြိုက်နှစ်သက်ရာတစ်ခုကို အသုံးပြုလိုက်ရင် ရပါပြီ။

'I go to school.' 

"I go to school ."

'''I go to school .'''

"""I go to school .""'

################################################

##### 2. int

-   notation is integer value

သင်္ကေတတစ်ခုမှ မသုံးထားခဲ့ရင် ကိန်းပြည့်အမျိုးအစားဖန်တီးခိုင်းလိုက်တယ်လို့ Python က ယူဆပါတယ်။

ဒါကြောင့် ကိန်းပြည့်တွေ ဖန်တီးမယ်ဆိုရင်တော့ စာဖန်တီးခဲ့သလိုမျိုး အပိုသင်္ကေတတွေ မလိုအပ်ပါဘူး။

1, 2 , 3 အစရှိတဲ့ ကိန်းပြည့်တန်ဖိုးတွေကို တိုက်ရိုက်ရေးလိုက်ရုံပါပဲ။

စာတန်ဖိုး အလွတ်လိုမျိုး ကိန်းပြည့်တန်ဖိုးအလွတ် ဖန်တီးချင်ရင်တော့ 0 လို့ ရေးနိုင်ပါတယ်။

zero  ဆိုတဲ့ နံပါတ်ကို integer တန်ဖိုးအလွတ်လို့ ယူဆနိုင်ပါတယ်။

################################################

##### 3. float                --->   .

floating point number လို့ခေါ်တဲ့ ဒဿမကိန်းတွေကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ decimal point ကို သုံးပါတယ်။

တန်ဖိုးအလွတ် ဖန်တီးချင်ရင်တော့ 0.0 လို့ ရေးနိုင်ပါတယ်။

တကယ်က floating point number ဖန်တီးဖို့အတွက် floating point တစ်ခုနဲ့ နံပါတ်တစ်ခုသာ လိုအပ်တာဖြစ်လို့

0.0

.0

0.

စသဖြင့် ကြိုက်သလို ရေးနိုင်ပါတယ်။

################################################

##### 4. complex              --->   j

complex number ကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ root -1 တန်ဖိုးကို ကိုယ်စားပြုဖို့အတွက်  j ကို သုံးပါတယ်။

How to represent complex number 9+10i in the 2D complex plane?

ဒီမေးခွန်းထဲကလိုမျိုး စက်ရုပ်ရဲ့ တည်နေရာကို  2D plane မှာ ဖော်ပြဖို့အတွက် 9 + 10 i လိုမျိုး  complex number ကို ဖန်တီးချင်ရင် 9 + 10j လို့ ရေးရပါမယ်။

9 + 10j ကို မြင်သာအောင် ပုံဖော်ပြရရင်

စက်ရုပ်ဟာ မူလစမှတ်ကနေ့ ရှေ့တည့်တည့် ကိုးမီတာအကွာနဲ့ ညာဘက်ဆယ်မီတာအကွာ အမှတ်နှစ်ခုဆုံကြတဲ့နေရာကို ရွေ့သွားခဲ့တယ် / ရောက်နေတယ်ဆိုတာမျိုးဖြစ်ပါတယ်။

################################################

##### 5. list                  --->   [ ]

list လို့ခေါ်တဲ့ ပြင်လို့ရတဲ့စာရင်းကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ square brackets ကို သုံးပါတယ်။

list ဖန်တီးဖို့အတွက် လေးထောင့်ကွင်းကို သုံးရမယ်ဆိုတာမျိုး မြန်မာလိုမှတ်ထားလည်းရပါတယ်။

################################################

##### 6. tuple                --->   ( )

ပြင်လို့မရတဲ့စာရင်းကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ round brackets ကို သုံးပါတယ်။ tuple ဖန်တီးဖို့ ဝိုက်ကွင်းကိုသုံးရမယ်ဆိုတာမျိုး မှတ်ထားလည်းရပါတယ်။

လေးထောင့်ကွင်းမြင်တာနဲ့ list ကို ဖန်တီးထားတယ်ဆိုတာမျိုး
ဝိုက်ကွင်းမြင်တာနဲ့ tuple ကို ဖန်တီးထားတယ်ဆိုတာမျိုး ကွဲကွဲပြားပြား သိနေရပါမယ်။

################################################

##### 7. range

range ကိုတော့ သင်္ကေတနဲ့ ဖန်တီးခွင့်မပေးထားပါဘူး။

################################################

##### 8. dict                 --->   { }

dictionary စာရင်းတစ်ခုကို သင်္ကေတနဲ့ ဖန်တီးချင်တဲ့အခါ curly bracket ကို သုံးပါတယ်။

တွန့်ကွင်းပေါ့။

################################################

##### 9. set                  --->   { }

အစုအဝေးဖန်တီးတဲ့အခါမှာလည်း တွန့်ကွင်းကိုပဲ သုံးရမှာဖြစ်ပါတယ်။

dictionary နဲ့ set နှစ်မျိုးလုံးက သင်္ကေတတူနေကြလို့ ဘယ်လိုကွာခြားလဲဆိုတာတွေနဲ့ သတိထားရမယ့်အချက်တွေကိုတော့ နောက်သင်ခန်းစာမှပဲ ထပ်ရှင်းပြပေးပါ့မယ်။

################################################

##### 10. frozenset

frozen set ကို သင်္ကေတနဲ့ ဖန်တီးခွင့်မပေးထားပါဘူး။

################################################။

##### 11. bool

-  notation is boolean value

-  True, False

integer ဖန်တီးခဲ့တာနဲ့ ပုံစံတူပါတယ်။

Boolean တန်ဖိုးတွေကတော့ integer လိုမျိုး တန်ဖိုးအများကြီး မရှိပဲ True နဲ့ False ဆိုပြီး တန်ဖိုးနှစ်ခုတည်းပဲ ရှိပါတယ်။

int ဖန်တီးခဲ့သလိုမျိုး အပိုသင်္ကေတတွေ မလိုအပ်တာဖြစ်လို့ True  ဒါမှမဟုတ် False ဆိုပြီး တိုက်ရိုက် ချရေးလိုက်ရုံပါပဲ။

တန်ဖိုးတွေ ကိုယ်တိုင်က အမှတ်အသားသဘော ဖြစ်နေတယ်လို့ ယူဆနိုင်ပါတယ်။

################################################

##### 12. bytes

bytes ကို သင်္ကေတနဲ့ ဖန်တီးလိုပါက b ကို အသုံးပြုနိုင်ပါတယ်။

'apple' ဟူသော စာကြောင်းတွင် ပါဝင်သော စာလုံးတစ်ခုချင်းစီ၏ Unicode အမှတ်စဉ်များကို binary တန်ဖိုး 8 bits အဖြစ် ဖန်တီးလိုပါက b'apple'  ဆိုပြီး ရေးသားနိုင်ပါသည်။

apple ၏ unicode အမှတ်စဉ်များသည် 97, 112, 112, 108, 101 စသည်‌တို့ ဖြစ်ကြသဖြင့် binary တန်ဖိုး 8 bits အဖြစ် ပြောင်းသည့်အခါ အောက်ပါအတိုင်း ရလာမှာဖြစ်ပါတယ်။

01100001 01110000  01110000  01101100  01100101

computer memory ထဲမှာ ခုလိုမျိုး ဖန်တီးထားပေးမှာဖြစ်ပါတယ်။

################################################

##### 13. bytearray

##### 14. memory view

ဒီနှစ်မျိုးကို သင်္ကေတနဲ့ ဖန်တီးခွင့်မပေးထားပါဘူး။

---

##### 15. NoneType

- notation is NoneType value

- None

integer, boolean နဲ့ NoneType ဒီသုံးမျိုးလုံးက အတူတူပါပဲ။

ဖန်တီးဖို့အတွက် အပိုသင်္ကေတ/အမှတ်အသားတွေ မလိုအပ်ပါဘူး။

တန်ဖိုးတွေ ကိုယ်တိုင်က အမှတ်အသားသဘောမျိုးဖြစ်နေတယ်လို့ ယူဆနိုင်ပါတယ်။

NoneType မှာတော့ None ဆိုတဲ့ တန်ဖိုးတစ်ခုပဲ ရှိသလို

အပိုသင်္ကေတတွေလည်း မလိုအပ်တာဖြစ်လို့ None ဆိုပြီး တိုက်ရိုက် ချရေးလိုက်ရုံပါပဲ။

---

မှတ်ရလွယ်အောင် အုပ်စုခွဲပြီး အနှစ်ချုပ်ရရင်

သင်္ကေတနဲ့ ဖန်တီးတာက စုစုပေါင်း 11 မျိုးရှိပြီး

8 မျိုးအတွက်က သက်ဆိုင်ရာသင်္ကေတတွေကို အလွတ်ကျက်ထားရပါမယ်။

သုံးမျိုးကတော့ တန်ဖိုးတွေကိုယ်တိုင်က သင်္ကေတတွေပါပဲ။

ကျန် 4 မျိုးကိုတော့ သင်္ကေတနဲ့ ဖန်တီးလို့မရဘဲ အမည်နဲ့ပဲ ဖန်တီးနိုင်တယ်လို့ မှတ်ထားရပါမယ်။

---

အလွတ်ရဖို့လိုအပ်တဲ့ သင်္ကေတ 8 မျိုးပါ။

1. str                  --->   ' ', " ", ''' ''', """ """

3. float                --->    .

4. complex              --->     j

5. list                 --->   [  ]

6. tuple                --->   (  )

8. dict                 --->   {  }

9. set                  --->   {  }

12. bytes               --->   b

---

တန်ဖိုးတွေကိုယ်တိုင်က သင်္ကေတဖြစ်ကြနေတဲ့ သုံးမျိုးပါ။

2. int ( -1, -2, 0, 1, 2 )

11. bool ( True, False )

15. NoneType ( None )

သတိပြုရမှာက True, False, နဲ့ None ကို ရေးတဲ့အခါ ရှေ့ဆုံးစာလုံးက အကြီးဖြစ်ရပါမယ်။

---

သင်္ကေတနဲ့ ဖန်တီးခွင့်မပေးထားတဲ့ 4 မျိုးပါ။

7. range

10. frozenset

13. bytearray

14. memory view

---

#### (B) Creating built-in data types with name

အမည်ဖြင့် ဖန်တီးနိုင်သော 14 မျိုး

1. str
2. int
3. float
4. complex
5. list
6. tuple
7. range
8. dict
9. set
10. frozenset
11. bool
12. bytes
13. bytearray
14. memoryview

---

အမည်ဖြင့် ဖန်တီးခွင့်မပေးထားပဲ သင်္ကေတဖြင့်သာ ဖန်တီးနိုင်သော data type

15. NoneType

---

အမည်နဲ့ ဖန်တီးကြရတဲ့အခါ

14 ခုလုံးကို ဒီအမည်တွေနဲ့ပဲ ဖန်တီးတာဖြစ်လို့

ဒီအတိုကောက်အမည်တွေကိုသာ အလွတ်ရထားခဲ့ရင် program ရေးတဲ့အခါ အဆင်ပြေပါပြီ။

---

အနှစ်ချုပ်ရရင်တော့ တကူးတက မှတ်စရာဆိုလို့ quotes, b, [ ], ( ), { } ဒီလေးခုနဲ့ True, False, None  ဒါပဲ ရှိပါမယ်။

integer, floating point number, complex number တွေကတော့ သင်္ချာမှာ သုံးခဲ့ကြတဲ့ပုံစံနဲ့ အတူတူပဲဖြစ်လို့ တကူးတက မမှတ်ထားလည်းရပါတယ်။

---

အမည်နဲ့ ဖန်တီးတတ်ဖို့အတွက် အတိုကောက်အမည် ဆယ့်လေးခုကို အလွတ်ရနေရပါမယ်။

သင်္ကေတနဲ့ ဖန်တီးတဲ့ ဆယ်ခုကိုလည်း သင်္ကေတနဲ့တွဲပြီး မှတ်မိနေရပါမယ်။

data types တွေကို  လက်တွေ့ ဖန်တီးတာတွေ မိမိလိုချင်တဲ့ data အမျိုးအစားဟုတ်/ မဟုတ် စစ်ဆေးတာတွေ ရှိထားတဲ့ data ကို ကိုယ်လိုချင်တဲ့ data ရအောင် ပြောင်းလဲတာတွေ စတာတွေကိုတော့ နောက်သင်ခန်းစာမှပဲ ထည့်ရေးပေးပါ့မယ်။

---

မေးခွန်းတွေကိုလည်း နောက်သင်ခန်းစာမှပဲ စုပြီး မေးပါ့မယ့်။

---

## 9. Callable Types

data အမျိုးအစား 15 မျိုးကို အဆင်သင့် ဖန်တီးပေးထားသလို data  မဟုတ်တဲ့ တစ်ခြားအမျိုးအစား 4 ခုကိုလည်း ဖန်တီးပေးထားပါသေးတယ်။

callable type လို့ ခေါ်ပါတယ်။

ဒီလေးမျိုးကို အမည်နဲ့ဖန်တီးတဲ့အခါ def , class, lambda စသဖြင့် အသုံးပြုပြီး ဖန်တီးနိုင်ပါတယ်။

မူလအမည်တွေကိုပဲ အတိုကောက်ပြန်ယူထားတာဖြစ်လို့ တကူးတက မှတ်ဖို့တော့ မလိုအပ်ပါဘူး။

---

Callable Types

1. functions      --->   def  (define, function definition)

2. methods        --->   def

3. classes        --->   class

4. lambda         --->   lambda

ဒီလေးမျိုးထည့်ပေါင်းလိုက်ရင် data types 15 မျိုးနဲ့ callable type 4 မျိုးဆိုပြီး စုစုပေါင်း built-in types 19 မျိုးရှိလာမှာ ဖြစ်ပါတယ်။

---

## 10. Naming rules 

Python ကတစ်ဆင့် data တွေကို ဖန်တီးခိုင်းလိုက်တဲ့အခါ computer ဟာ RAM ပေါ်မှာ ဖန်တီးပေးပါတယ်။

RAM ရဲ့ အမည်အပြည့်အစုံဟာ randomly access memory ဖြစ်ပါတယ်။

randomly access ဆိုတာက data တွေကို နေရာအတည်တကျမထားပဲ လွတ်တဲ့နေရာကို ထိုးထည့်တာမျိုး ကြုံရင်ကြုံသလို သိမ်းတာမျိုးပေါ့။

စာအုပ်စင်ပေါ်မှာ စာအုပ်တစ်အုပ်ချင်း အကန့်အလိုက် အစီအစဉ်တကျ သိမ်းတာမျိုးမဟုတ်ပဲ စုဘူးထဲကို အကြွေစေ့ပစ်ထည့်လိုက်သလိုမျိုး random သိမ်းတာဖြစ်လို့ ဖန်တီးလိုက်တဲ့ data ဘယ်မှာ ရှိနေတယ်ဆိုတာမျိုး အလွယ်တကူ မသိနိုင်ပါဘူး။

---

Procedural programming ဆိုတာက အတိအကျသိပြီး အသေးစိတ်ထိန်းချုပ်ရတာမျိုးဖြစ်လို့ data ရှိနေတဲ့နေရာကို သိရှိနေဖို့ လိုအပ်ပါတယ်။

အတိအကျသိနေဖို့ RAM မှာ မသိမ်းပြန်ရင်လည်း computer က မြန်မြန်ဆန်ဆန် အလုပ်လုပ်နိုင်မှာ မဟုတ်ပြန်ပါဘူး။

ဒါကြောင့် မြန်ဆန်ဖို့အတွက် RAM ကိုပဲ အသုံးပြုကြပေမယ့် ကြုံရာဖန်တီးလိုက်လို့ random ဖြစ်ပေါ်လာတဲ့ နေရာလေးကို မှတ်သားဖို့အတွက်တော့ အမည်တစ်ခုကို ကြားခံအသုံးပြုကြပါတယ်။

ဒီလိုနဲ့ မူလ စွမ်းဆောင်ရည်လည်း မလျော့တော့သလို ကျွန်တော်တို့ သိလိုတဲ့ data ရှိရာနေရာလေးကိုလည်း မှတ်သားထားနိုင်ပြီ ဖြစ်ပါတယ်။

---

data ရှိရာ နေရာကို မှတ်သားဖို့အတွက် အမည်တွေ ပေးတဲ့အခါ စည်းမျဉ်း 5 ခုရှိပါတယ်။

1. အနည်းဆုံး စာလုံးတစ်လုံးပါဝင်ရပါမယ်။ (  x = 5 )

2. ရှေ့ဆုံးစာလုံးသည် abcd, ကခ ကဲ့သိုသော "alphabet" ဖြစ်ရပါမည်။ ( age = 5 ) ( အသက် = 5 )
လိုအပ်ပါက underscore ကိုလည်း အသုံးပြုနိုင်ပါသည်။ (  _ = 5)

3. အမည်သည် စာလုံးတစ်လုံးထက် ပိုမိုခဲ့မည်ဆိုပါက ကျန်စာလုံးများတွင် နံပါတ်များကိုလည်း ထည့်သွင်းအသုံးပြုနိုင်ပါသည်။ ( age1 = 5 )
alphabet နဲ့ underscore ကတော့ ပထမစလုံးကနေစပြီး အကုန်လုံးမှာ ထည့်လို့ရပါတယ်။
ဆိုလိုတာက အမည်ပေးတဲ့အခါ ဒီသုံးမျိုးပဲ သုံးရမယ်ဆိုတာမျိုးပါပဲ။

4. ဒီလိုနဲ့ပဲ ဒီသုံးမျိုးမဟုတ်ခဲ့ရင် သုံးခွင့်မရှိတာကတော့ စတုတ္ထစည်းမျဉ်းအဖြစ် ဖြစ်လာခဲ့ပါတယ်။

5. Python မှာ ကြိုတင်ယူသုံးထားပြီးသား အမည်တွေကိုလည်း အမည်တွေမထပ်စေဖို့အတွက် အသုံးပြုခွင့်မပေးထားပါဘူး။

---

အတိအကျလိုက်နာရမည့် စည်းမျဥ်းများထဲမှာ မပါဝင်သော်လည်း အလိုက်တသိလိုက်နာရမည့် ကျင့်ဝတ်တစ်ခုရှိပါသည်။

ဒါကတော့ အမည်ပေးရာမှာ သင့်တော်မယ့်အမည်တွေ ပေးဖို့ပဲ ဖြစ်ပါတယ်။

ဒါမှသာ အမည်တွေ့ရုံနဲ့ program ကို နားလည်နိုင်မှာ ဖြစ်ပါတယ်။

Python ကိုယ်တိုင်ကလည်း ဒီစည်းမျဉ်းကို လိုက်နာပါတယ်။

integer ဖန်တီးဖို့အတွက် သုံးထားတဲ့အမည်ကို  int လို့ ပေးထားပြီး character string ဖန်တီးဖို့ သုံးထားတဲ့အမည်ကိုတော့ str လို့ ပေးထားခဲ့သလို တစ်ခြားအမည်တွေလည်း အတူတူပါပဲ။

ဒါကြောင့်သာ types 19 မျိုးကို အမည်နဲ့ဖန်တီးဖို့အတွက် မှတ်သားကြရတဲ့အခါ လွယ်ကူနေတာပဲ ဖြစ်ပါတယ်။

---

ဒါကတော့ English လိုမှတ်ထားဖို့ပါ။

Python has five rules for naming identifiers.

( one, alpha, number, o, r )

1. An identifier must contain at least one character.

2. The first character of an identifier must be an alphabet or the underscore.

3. The remaining characters may be alphabets, underscores, numbers.

4. Qther characters are not permitted.

5. A reserved keyword cannot be used as an identifier.

6. meaningful

---

one, alpha, number, o, r ဆိုပြီး အတိုကောက်မှတ်ထားလို့ရပါတယ်။

( ဝမ်း အယ်ဖာ number  အော် )

1. ဝမ်းကတော့ စာတစ်လုံး အနည်းဆုံးပါရမှာကို ပြောတာပါ။

2. alpha တော့ ပထစာလုံးက alphabet ဖြစ်ရမယ်ဆိုတာမျိုးပေါ့။ ( underscores ကိုတော့ အထူးအခြေအနေမှာပဲ သုံးကြပါတယ်။ )

3. number ကတော့ နံပါတ်တွေလည်း သုံးနိုင်တယ်လို့ ဆိုလိုတာပါ။

4. o ကတော့ other characters တွေ မသုံးမိဖို့ပါ။

5. r ကတော့ reserved keywords လို့ခေါ်တဲ့ Python မှာ သုံးထားပြီးသား def, class လိုမျိုးတွေ မသုံးမိဖို့ပါပဲ။

ဒါကတော့ သုံးခွင့်မရှိတဲ့ reserved keywords 35 ခု ဖြစ်ပြီး

Python version အမျိုးအစားအလိုက် အတိုးအလျော့ရှိနိုင်ပါသည်။

\['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global',
'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise',
'return', 'try', 'while', 'with', 'yield']

class ကလွဲလို့ ကျန်အမည်တွေက ပေးလေ့ပေးထမရှိတဲ့ အမည်တွေ ဖြစ်ကြပါတယ်။

ဒါကြောင့် မှားပေးမိစရာအကြောင်းလည်း မရှိလို့ တကူးတက မှတ်သားထားဖို့ မလိုအပ်ပါဘူး။

---

##### ကိုယ်စားပြုအမည် အမျိုးအစားများ

တန်ဖိုးတစ်ခုခုကို ကိုယ်စားပြုရန်အတွက် အမည်သတ်မှတ်ရာတွင် ဘာသာစကားအမျိုးမျိုးဖြင့် အမည်ပေးနိုင်သော်လည်း လူအများနားလည်လွယ်စေရန်အတွက် အင်္ဂလိပ်လိုသာ အမည်ပေးလေ့ရှိကြပါသည်။

အင်္ဂလိပ်လို အမည်ပေးရာတွင် အောက်ပါ လေးမျိုးကို အသုံးများကြပါသည်။

1. Upper case

2. Lower case

3. Snake case

4. Upper cameal case

---

###### 1. Upper case

အမည်အားလုံးကို အင်္ဂလိပ်အက္ခရာ အကြီးစာလုံးဖြင့် ရေးသားခြင်းဖြစ်ပါသည်။

အနီရောင်ဟူသောစာတန်ဖိုးကို ကိုယ်စားပြုအမည်ပေးရန်အတွက် အောက်ပါအတိုင်းရေးသားနိုင်ပါသည်။

COLOR = "red"

COLOR ဟူသော အမည်သည် upper case အမည် ဖြစ်ပါသည်။

---

###### 2. Lower case

အမည်အားလုံးကို အင်္ဂလိပ်အက္ခရာ အသေးစာလုံးဖြင့် ရေးသားခြင်းဖြစ်ပါသည်။

အသက် 20 ဟူသော ကိန်းဂဏန်းတန်ဖိုးကို ကိုယ်စားပြုအမည်ပေးရန်အတွက် အောက်ပါအတိုင်း ရေးသားနိုင်ပါသည်။

age = 20

age ဟူသော အမည်သည် lower case အမည် ဖြစ်ပါသည်။

--- 

###### 3. Snake Case

lower case ကဲ့သို့ အမည်အားလုံးကို အင်္ဂလိပ်အက္ခရာအသေးစာလုံးဖြင့် ရေးသားထားသော်လည်း

ဖတ်ရလွယ်ကူစေရန်အတွက် စကားစုများအကြားတွင် underscores များကို ကြားညှပ်ပြီး အသုံးပြုထားရာမှ မြွေပုံစံဖြစ်နေသဖြင့် snake case ဟူ၍ ခေါ်ကြပါသည်။

my_mother_country = "Myanmar"

တန်ဖိုးတစ်ခုခုကို ကိုယ်စားပြုမည့် အမည်များ သတ်မှတ်ရာတွင် space များကို အသုံးပြုခွင့်မရှိပါ။

my mother country ဟူ၍ space ခြားပြီး အမည်ပေး၍ မရသဖြင့် mymothercountry ဟူ၍ ရေးသားပါက ဖတ်ရခက်မည် ဖြစ်ပါသည်။

ဖတ်ရလွယ်စေလိုပါက စကားစုနှစ်ခုကြားတွင် underscore ခံပြီး my_mother_country ဟူ၍ အမည်ပေးနိုင်ပါသည်။

--- 

###### 4. Upper cameal case

စကားစုများကို ဖတ်ရလွယ်စေရန်အတွက် အစ စာလုံးများကို စာလုံးအကြီးများဖြင့် ရေးသားရာမှ ကုလားအုတ်ကျောကဲ့သို့ အနိမ့်အမြင့်ဖြစ်သွားသဖြင့် Upper cameal case ဟူ၍ ခေါ်ကြပါသည်။

MyMotherCountry = "Myanmar"

my mother country ဟူ၍ space ခြားပြီး အမည်ပေး၍ မရသဖြင့် ဖတ်ရလွယ်စေရန်အတွက် MyMotherCountry ဟူ၍ ရေးသားထားခြင်းမျိုးသည် upper cameal case ဖြစ်ပါသည်။

--- 

###### Python Enhancement Proposal  (PEP 8 – Style Guide for Python Code)

Python ကို ဖန်တီးခဲ့သူ Guido van Rossum နှင့် အခြား Python Developer များ စုပေါင်းရေးသားခဲ့သော Python ပုံစံ ပရိုဂရမ်ရေးသားခြင်းအတွက် အကြံပြုချက် ဖြစ်ပါသည်။

program  ရေးသားပုံရေးသားနည်းများကို  အကြံပြုထားခြင်း ဖြစ်ပါသည်။

အမည်တွေ့ရုံမျှဖြင့် variable, constant, function, method, class စသဖြင့် ချက်ချင်းခွဲခြားပြီး သိရှိနိုင်စေရန် တစ်နည်းအားဖြင့် နားလည်ရလွယ်ကူစေရန်အတွက် စည်းကမ်းသတ်မှတ်ခဲ့ကြခြင်း ဖြစ်ပါသည်။

တန်ဖိုးများ အမည်ပေးရာတွင် အသုံးပြုရမည့် case များနှင့် ပတ်သတ်ပြီး ဒီနှစ်ချက်ကို ရေးသားထားပါသည်။

1. သာမန်တန်ဖိုးတစ်ခုခုကို အမည်ပေးလိုပါက lower case နှင့် snake case ကိုသာ အသုံးပြုရပါမည်။

2. ကိန်းသေတန်ဖိုးများကို အမည်ပေးလိုပါက upper case ကို အသုံးပြုရပါမည်။

--- 

အခြားစည်းကမ်းချက်များကိုတော့ သက်ဆိုင်ရာ သင်ခန်းစာသင်ပြီးမှသာ ထပ်ဖြည့်ပေးပါမည်။

--- 

## 11. Creating empty data with notations  ( PP )

data အမျိုးအစားတွေဖန်တီးတဲ့အခါ လိုအပ်ချက်အရ တန်ဖိုးအလွတ်တွေ ဖန်တီးရတာမျိုးရှိပါတယ်။

တန်ဖိုးအလွတ်တွေ ဖန်တီးကြတဲ့အခါ notations လို့ခေါ်တဲ့ သင်္ကေတနဲ့လည်း ဖန်တီးနိုင်သလို အမည်ဖြင့်လည်း ဖန်တီးနိုင်ပါတယ်။

ပထမဆုံး သင်္ကေတနဲ့ ဖန်တီးပြပါမယ်။

--- 

###### 1. str

Empty characters string လို့ ခေါ်တဲ့ စာတန်ဖိုးအလွတ်ဖန်တီးလိုပါက opened quotation mark နဲ့ closed quotation mark တွေကို သုံးလိုက်ရုံပါပဲ။

အသုံးပြုနိုင်တဲ့ quotation mark က 4 မျိုးရှိနေလို့ 4 မျိုးလုံးကို သုံးပြီး ဖန်တီးပြထားပါတယ်။

a . Creating empty characters string with single quotes --->   ''

b. Creating empty characters string with double quotes ---> ""

c. Creating empty characters string with triple quotes ( single ) ---> ''''''

d. Creating empty characters string with triple quotes ( double ) ---> """"""

--- 

###### 2. int

သုညကို တန်ဖိုးမရှိကြောင်း ဖော်ပြဖို့အတွက် အသုံးပြုတာဖြစ်လို့ Empty integer လို့ ယူဆနိုင်ပါတယ်။

Creating empty integer   --->   0

--- 

###### 3. float

floating point number တွေမှာလည်း သုညပါပဲ။

Creating empty floating point number  --->   0.0

--- 

###### 4. complex

complex number တွေမှာလည်း သုညပါပဲ။

Creating empty complex number   --->   0j

--- 

###### 5. list

Empty list လို့ခေါ်တဲ့ စာရင်းအလွတ်ဖန်တီးလိုပါက ထောင့်ကွင်းကို အသုံးပြုရုံပါပဲ။

Creating empty list   --->   [ ]

--- 

###### 6. tuple

Empty tuple လို့ခေါ်တဲ့ ပြင်ခွင့်မရှိအောင် ပြုလုပ်ထားတဲ့ စာရင်းအလွတ်ဖန်တီးလိုပါက ဝိုက်ကွင်းကို အသုံးပြုရုံပါပဲ။

Creating empty tuple   --->   ( )

--- 

###### 7. range

empty range ဖန်တီးနိုင်သော်လည်း သင်္ကေတမရှိသဖြင့် အမည်ဖြင့်သာ ဖန်တီးနိုင်ပါသည်။

--- 

###### 8. dict

Empty dictionary ဖန်တီးလိုပါက တွန့်ကွင်းကို အသုံးပြုရုံပါပဲ။

Creating empty dictionary   --->   { }

--- 

###### 9. set

dict နဲ့ set ဟာ သင်္ကေတအတူတူဖြစ်ကြပြီး တွန့်ကွင်းအလွတ်ကို အဓိပ္ပါယ်သတ်မှတ်ဖို့အတွက် တစ်ခုရွေးရတဲ့အခါ set ကို အသုံးနည်းတာဖြစ်လို့ empty dict လို့ပဲ သတ်မှတ်ထားပါတယ်။

ဒါကြောင့် empty set ကို သင်္ကေတနဲ့ ဖန်တီးလို့ မရတော့ပါဘူး။

--- 

###### 10. frozenset

empty frozen set ဖန်တီးနိုင်သော်လည်း သင်္ကေတမရှိသဖြင့် အမည်ဖြင့်သာ ဖန်တီးနိုင်ပါသည်။

--- 

###### 11. bool

Boolean တန်ဖိုး False ကို သုညလိုမျိုး  တန်ဖိုးမရှိဘူးဆိုတာမျိုး ယူဆနိုင်ပါတယ်။

Creating empty Boolean data   --->   False

--- 

###### 12. bytes

Empty byte ဖန်တီးလိုပါက b နဲ့ quotation mark ကို အသုံးပြုနိုင်ပါတယ်။ quotation mark လေးမျိုးလုံးနဲ့ တွဲစပ်နိုင်ပါတယ်။

Creating empty bytes   --->   b''

--- 

###### 13. bytearray

Empty byte array ဖန်တီးနိုင်သော်လည်း သင်္ကေတမရှိသဖြင့် အမည်ဖြင့်သာ ဖန်တီးနိုင်ပါသည်။

--- 

###### 14. memoryview

Empty memory view ဖန်တီးနိုင်သော်လည်း သင်္ကေတမရှိသဖြင့် အမည်ဖြင့်သာ ဖန်တီးနိုင်ပါသည်။

--- 

###### 15. NoneType

None ဟူသော တန်ဖိုးတစ်ခုတည်းသာ ရှိပါသည်။

None ကို data မရှိကြောင်း ဖော်ပြဖို့အတွက် အသုံးပြုတာဖြစ်လို့ empty လို့ ယူနိုင်ပါတယ်။

--- 

## 12. Creating empty data with names  ( PP )

တန်ဖိုးအလွတ်တွေကို အမည်နဲ့ ဖန်တီးပြပါမယ်။

--- 

###### 1. str

Empty characters string လို့ ခေါ်တဲ့ စာတန်ဖိုးအလွတ်ကို အမည်နဲ့ဖန်တီးလိုပါက str() လို့ ရေးလိုက်ရုံပါပဲ။

--- 

###### 2. int

Empty integer ကို အမည်နဲ့ ဖန်တီးလိုပါက int() လို့ ရေးလိုက်ရုံပါပဲ။

တန်ဖိုးအနေနဲ့ သုညဖြစ်ပါမယ်။

Creating empty integer   --->   int()

--- 

###### 3. float

Empty floating point number ကို အမည်နဲ့ ဖန်တီးလိုပါက float() လို့ ရေးလိုက်ရုံပါပဲ။

တန်ဖိုးအနေနဲ့ 0.0 ဖြစ်ပါမယ်။

Creating empty floating point number  --->   float()

--- 

###### 4. complex

complex number ကို အမည်နဲ့ ဖန်တီးလိုပါက complex() လို့ ရေးလိုက်ရုံပါပဲ။

တန်ဖိုးအနေနဲ့ 0j ဖြစ်ပါမယ်။

Creating empty complex number   --->   complex()

--- 

တကယ်တော့  empty valve တွေကို ဖန်တီးတဲ့အခါ အမည်တွေနောက်မှာ ဝိုက်ကွင်းတပ်ပြီး ရေးလိုက်ရုံပါပဲ။

ထွက်လာတဲ့ရလဒ်တွေကတော့ notations နဲ့ဖန်တီးချိန်မှာ ပြောခဲ့သလိုပါပဲ။

1. str
2. int
3. float
4. complex
5. list
6. tuple
7. range
8. dict
9. set
10. frozenset
11. bool
12. bytes
13. bytearray
14. memoryview

--- 

သတိထားရမှာ နှစ်ခုရှိပါတယ်။

14 ခုမြောက်က memoryview က data ဖန်တီးတာ မဟုတ်ပဲ memory ကို တိုက်ရိုက် access လုပ်ဖို့ သုံးတာမျိုးဖြစ်လို့ အလွတ်ဖန်တီးချင်ရင် empty byte ထည့်ပေးရပါတယ်။

memoryview(b'') ဒါမှမဟုတ် memoryview(bytes()) ဆိုပြီး ဖြစ်သွားပါမယ်။

range ကလည်း data ဖန်တီးတယ်ဆိုတာထက် ကိန်းဂဏန်းအစီအစဉ်တစ်ခု ထုတ်ပေးတာဖြစ်လို့ empty range ဖန်တီးချင်ရင် empty integer ထည့်ပေးရပါတယ်။

range(0) ဒါမှမဟုတ် range(int()) ဆိုပြီး ဖန်တီးရပါမယ်။

--- 

Exercises အနေနဲ့ကတော့

1. ကျွန်တော် မရေးပြခဲ့တဲ့ ဒီရှစ်ခုရဲ့ empty valve တွေကို အမည်နဲ့ ဖန်တီးပြရပါမယ်။

5. list

6. tuple

8. dict

9. set

10. frozenset

11. bool

12. bytes

13. bytearray

--- 

2\. int() လို့ ရေးလိုက်ရင် empty integer ဖန်တီးပေးပါမယ်။ integer ရဲ့ empty value ဟာ သုညဖြစ်လို့ တန်ဖိုးက 0 ဖြစ်မယ်ဆိုတာမျိုး  အပေါ်ရှစ်ခုရဲ့ empty valve တစ်နည်းအားဖြင့် တန်ဖိုးအလွတ်တွေကို ခန့်မှန်းပေးပါ။

မသိတဲ့ တန်ဖိုးတွေကိုတော့ ကွက်လပ်ချန်ထားခဲ့နိုင်ပါတယ်။

--- 

## 13. character code  မိတ်ဆက်

စာတွေဖန်တီးတဲ့အခါ မြင်နိုင်တဲ့စာနဲ့ မမြင်နိုင်တဲ့စာဆိုပြီး နှစ်မျိုးခွဲခြားနိုင်ပါတယ်။

I am a student.

အထက်ပါ စာကြောင်းတွင် Iamastudent. သည် မြင်နိုင်သော အက္ခရာများဖြစ်ကြပြီး ကြားတွင် ခြားထားသော space သုံးခုသည် မမြင်နိုင်သော အက္ခရာများ ဖြစ်ကြပါသည်။

မမြင်နိုင်တဲ့ စာလုံးတွေမှာ ရေးလို့လွယ်တာရှိသလို ရေးလို့မလွယ်တာတွေလည်း ရှိကြပါတယ်။

```
I am a student.
I go to school.
```

အထက်ပါစာကြောင်းတွင် မမြင်နိုင်သော စာလုံးနှစ်မျိုးပါရှိသည်။
ပထမတစ်ခုမှာ space character ဖြစ်ပြီး ကျန်တစ်ခုမှာ new line character ဖြစ်ပါသည်။

ဖုန်းမှာပါတဲ့ ညာဘက် အောက်ထောင့်က မြှားအကွေးလေး တစ်နည်းအားဖြင့် Enter ဒါမှမဟုတ် Return လို့ ခေါ်တဲ့ ခလုတ်ကို နှိပ်လိုက်တာက new line character လို့ခေါ်တဲ့ မမြင်ရတဲ့ စာကို ရေးလိုက်တာပါပဲ။

သူဟာ ယူနီကုတ်လို့ခေါ်တဲ့ ကမ္ဘာတစ်ခုလုံးက အက္ခရာစဉ်မှတ်တမ်းမှာ ဆယ်ခုမြောက် အက္ခရာဖြစ်ပါတယ်။

space ကတော့ 32 ခုမြောက် အက္ခရာဖြစ်ပါတယ်။

တစ်ခြားအက္ခရာတွေနဲ့ နှိုင်းယှဉ်ပြရရင်

English အက္ခရာ အေအကြီး ' A ' ကတော့ ခြောက်ဆယ့်ငါးခုမြောက် အက္ခရာဖြစ်ပြီး
အေအသေး ' a ' ကတော့ ကိုးဆယ့်ခုနှစ်ခုမြောက် အက္ခရာဖြစ်ပါတယ်။

မြန်မာအက္ခရာ ကကြီး ' က ' ကတော့ လေးထောင့် ကိုးဆယ့်ခြောက်ခုမြောက် အက္ခရာဖြစ်ပါတယ်။

Victory Hand emoji (✌️)  လို့ ခေါ်တဲ့ လက်နှစ်ချောင်းထောင်တာကတော့ 9996 ခြောက်ခုမြောက် အက္ခရာဖြစ်ပါတယ်။

--- 

ကွန်ပြူတာကို စာတွေ သိမ်းခိုင်းလိုက်တဲ့အခါ မြင်နေရတဲ့ စာတွေကို မှတ်ထားတာမဟုတ်ပဲ နောက်ကွယ်မှာ ယူနီကုတ်လို့ခေါ်တဲ့ အက္ခရာစဉ်နံပါတ်တွေကိုပဲ မှတ်သားပြီး သိမ်းဆည်းပါတယ်။

ဘာကြောင့်လဲဆိုတော့ ကွန်ပြူတာက on off ဆိုတဲ့ ခလုတ်တွေ အများကြီး ရှိသလိုမျိုးပဲ ဖြစ်နေလို့ပါ။

လူလိုမျိုး မှတ်သားနိုင်စွမ်းမရှိပါဘူး။

ခလုတ်အများကြီးရှိလို့ အပိတ်အဖွင့်အများကြီး လုပ်လို့ရသလိုမျိုးပါပဲ။

ဥပမာ A ကို သိမ်းမယ်ဆိုပါစို့။

သူဟာ ခြောက်ဆယ့်ငါးခုမြောက်အက္ခရာဖြစ်လို့ 65 ကို ကိုယ်စားပြုတဲ့ binary တန်ဖိုး 0100 0001 အဖြစ် ကွန်ပြူတာထဲမှာ သိမ်းလိုက်ပါတယ်။

0100 0001

ခလုတ်ရှစ်ခုမှာ ညာဘက်က ရေတွက်ရင် ပထမဆုံးခလုတ်နဲ့ ခုနှစ်ခုမြောက်ခလုတ်ကို On ပြီး ကျန်တဲ့ ခြောက်ခု Off ထားလိုက်တာပါ။

--- 

##### bit 

ခလုတ်လိုမျိုး On,  Off မှတ်သားနိုင်တဲ့ အရာကို bit လို့ ခေါ်ပါတယ်။

အခုက bit ရှစ်ခုကို အသုံးပြုပြီး A ရဲ့ ယူနီကုတ်နံပါတ်ကို မှတ်သားထားတာဖြစ်ပါတယ်။

--- 

##### byte 

bit ရှစ်ခုကို byte တစ်ခုလို့ သတ်မှတ်ပါတယ်။

--- 

##### one byte per character 

bit ရှစ်ခုကို byte တစ်ခုလို့ သတ်မှတ်တာဖြစ်လို့ A ကို ကိုယ်စားပြုတဲ့အမှတ်စဉ် 65 က byte တစ်ခုစာ နေရာယူပါတယ်။

--- 

##### Mega bytes 

A လိုမျိုး အင်္ဂလိပ်အက္ခရာတစ်ခုကို byte တစ်ခုကုန်လို့ 1 MB မှာဆိုရင်တော့ A လိုမျိုး စာလုံးတွေ တစ်သန်းကျော် သိမ်းဆည်းနိုင်ပါတယ်။

မြန်မာစာကတော့ တစ်လုံးကို byte နှစ်ခုစာ နေရာယူပါတယ်။

ကကြီးရဲ့ အမှတ်စဉ် 4096 ကို binary ပုံစံရေတွက်ရင် ခုလိုရပါတယ်။

0001 0000 0000 0000

ဆယ့်သုံးခုမြောက် bit ကို On ပြီး ကျန်တာ off လိုက်တာမျိုး မှတ်သားထားမှာပေါ့။

bit တွေကို ရှစ်ခုတစ်တွဲ သုံးလေ့ရှိကြပါတယ်။

ကကြီးက 13 bits ဆိုပေမယ့် 16 bits နဲ့ပဲ မှတ်သားပါတယ်။

တကယ်လို့ မြန်မာစာအုပ်နဲ့ English စာအုပ် စာလုံးအရေအတွက်တူနေခဲ့ရင် မြန်မာစာအုပ်ကို ကွန်ပြူတာမှာ သိမ်းတဲ့အခါ နှစ်ဆနီးပါးပိုပြီး နေရာယူပါလိမ့်မယ်။

--- 

##### one byte per piexel 

ပုံတွေ video တွေမှာပါတဲ့ အရောင်တွေကိုလည်း ဒီလိုပဲ သိမ်းတာပါပဲ။

ဖုန်းမျက်နှာပြင်မှာ pixels လို့ခေါ်တဲ့ အလင်းစက် သန်းနဲ့ချီပြီး ရှိပါတယ်။

ပုံတွေကို ကွန်ပြူတာမှာ သိမ်းဆည်းတဲ့အခါ အလင်းစက်တစ်ခုချင်းစီရဲ့ အရောင်တစ်ခုချင်းစီကို byte တစ်ခုစာ နေရာယူပြီးသိမ်းပါတယ်။

ဒါကြောင့် စာအုပ်တစ်အုပ်နဲ့ ပုံတစ်ပုံက 1 MB ချင်း တူနေကြတာပါ။

video ဆိုရင်တော့ ပုံတွေအများကြီးကို သက်ဆိုင်ရာ အစီအစဉ်အတိုင်း ဆက်တိုက်ပြရတာမျိုး သိမ်းရတာမျိုးဖြစ်လို့ ပိုပြီး memory ကုန်ပါတယ်။

--- 

သိမ်းထားတဲ့စာကို ပြန်ပြရင်တော့ ဆိုင်ရာကုတ်နံပါတ်အတိုင်း အက္ခရာတွေနဲ့ ပြန်ပြပေးပါတယ်။

ပုံကို ပြန်ပြရင်တော့ ဆိုင်ရာ အရောင်နံပါတ်တွေအတွက် အလင်းစက်တွေကို အရောင်လင်းပေးလိုက်ပါတယ်။

computer က ပုံတွေ စာတွေ မသိပါဘူး။

ဘီလီယံနဲ့ ချီတဲ့ ခလုတ်တွေပဲ ရှိပါတယ်။

--- 


## 14. Primitive data type

program ရေးသားရာတွင် အခြေခံအကျဆုံး data လေးမျိုး ရှိပါသည်။

1. integer

2. floating point number

3. unicode character string

4. Boolean value

စသည်တို့ ဖြစ်ကြပါသည်။

--- 

##### 1. integer

မြန်မာလို အဓိပ္ပါယ်မှာ ကိန်းပြည့်ဖြစ်ပါသည်။

ကိန်းပြည့်ဆိုသည်မှာ တစ်ခု ၊ နှစ်ခု စသဖြင့် အပြည့်အဝရှိခြင်းကို ဆိုလိုခြင်းဖြစ်ပါသည်။

မြင်သာအောင် ပြောရပါက ကိတ်မုန့်တစ်ခု ၊ သစ်သီးဆယ်လုံး စသည်တို့သည် အပြည့်အဝရှိသော အရာများဖြစ်ကြပြီး

ကိတ်မုန့် တစ်ခုနဲ့ တစ်ဝက် ၊ သစ်သီးတစ်စိတ် စသည်တို့သည် အပြည့်အဝမရှိသော အစွန်းထွက်နေ‌သော တန်ဖိုးများဖြစ်ကြပါသည်။

--- 

##### 2. floating point number

float ဖြစ်နေသည့် point ပါသော နံပါတ်များဟူ၍ အဓိပ္ပါယ်ပြန်နိုင်ပါသည်။

တစ်ဆယ်နှင့်စားထားကြောင်း ဖော်ပြသည့် decimal point ပါသော နံပါတ်များဟူ၍လည်း အဓိပ္ပါယ်ပြန်နိုင်ပါသည်။

အလွယ်ပြောရရင် ဒဿမကိန်း / ဆယ်လီစိတ်ကိန်း / တစ်ဆယ်နဲ့ စားထားသော အစိတ်အပိုင်းပါသောနံပါတ်များကို ဆိုလိုတာဖြစ်ပါတယ်။

ဥပမာပေးရရင် 0.1 ဆိုရင် ဆယ်ပုံတစ်ပုံဖြစ်ပါမယ်။ point ရဲ့ ညာဘက် တစ်ခုအကွာဟာ တစ်ဆယ်တစ်ထပ်နဲ့ စားထားတယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

0.001 ကတော့ တစ်ထောင်ပုံတစ်ပုံဖြစ်ပါမယ်။ decimal point ရဲ့ညာဘက် သုံးခုမြောက်နေရာမှာရှိလို့ တစ်ဆယ်သုံးထပ်နဲ့ စားထားတယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

--- 

သင်္ချာဆိုင်ရာ ပေါင်း / နှုတ် / မြှောက် / စား လုပ်ဆောင်ချက်များအတွက် integer (ကိန်းပြည့်) နှင့် floating point number (ဒဿမကိန်း) တို့ကို အသုံးပြုနိုင်ပါသည်။

--- 

##### 3. unicode character string

Unicode  ဆိုတာက ကမ္ဘာတစ်ခုလုံးက စာလုံးတွေကို တူညီတဲ့ နံပါတ်ပေးထားကို ပြောတာပါ။

မြင်သာအောင် ရှင်းပြရရင်

ကွန်ပြူတာတွေမှာ A ကို ပြဖို့အတွက် ကြိုက်နှစ်သက်ရာ နံပါတ်ကို အသုံးပြုနိုင်ပါတယ်။

ကွန်ပြူတာတစ်ခုမှာ 10 ကို A ရဲ့ နံပါတ်အဖြစ် ပေးထားခဲ့ပြီး တစ်ခြား computer မှာ B  လို့ ပေးထားခဲ့ရင် ပထမကွန်ပြူတာက စာကို တစ်ခြားကွန်ပြူတာမှာ ဖွင့်တဲ့အခါ A လို့ မပြပဲ B လို့ ပြမှာ ဖြစ်ပါတယ်။

ဒါကြောင့် ကွန်ပြူတာအားလုံးမှာ အတူတူပြစေချင်တဲ့အတွက် code နံပါတ်တစ်ခုတည်းကို ကမ္ဘာတစ်ခုလုံး အတူတူသုံးကြမယ်ဆိုတာမျိုး သတ်မှတ်ပြီး ဖန်တီးလိုက်ကြပါတယ်။

တူညီသော ကုတ်နံပါတ်တွေလို့ ခေါ်ပါတယ်။

ဘိုလို အသံထွက်ရင်တော့ ယူနီကုတ်ပေါ့။

uni ဆိုတာက တူညီတာဖြစ်ပြီး code ကတော့ တစ်ခုခုကို ကိုယ်စားပြုထားတဲ့ နံပါတ်ဖြစ်ပါတယ်။

--- 

အင်္ဂလိပ်အက္ခရာ A ဟာ unicode အမှတ်စဉ် 65 ဖြစ်ပြီး  B ဟာ 66 ဖြစ်ပါတယ်။

မြန်မာအက္ခရာ ကကြီး ကတော့ အမှတ်စဉ် 4096 ဖြစ်ပြီး ခကွေးကတော့ 4097 ဖြစ်ပါတယ်။

လက်နှစ်ချောင်းထောင်တဲ့ victory hand ✌️ လို့ ခေါ်တဲ့ emoji ကတော့ 9996 ခုမြောက်မှာ ရှိပါတယ်။

--- 

စာများနှင့်ပတ်သတ်သော လုပ်ဆောင်ချက်များအတွက် unicode character string ကို အသုံးပြုနိုင်ပါသည်။

ဥပမာပေးရရင် ဝတ္ထုစာအုပ်ထဲက ဇာတ်ကောင် မောင်မောင်ဆိုတဲ့အမည်ကို မောင်အောင်လို့ ပြောင်းချင်တဲ့အခါ ဝတ္ထုတစ်အုပ်လုံး လက်နဲ့ လိုက်မပြင်ချင်လို့ Python program တစ်ကြောင်းလောက်နဲ့ ပြင်ခိုင်းလိုက်တာမျိုးပေါ့။

--- 

##### 4. Boolean

Boolean သည် British သင်္ချာပညာရှင် George Boole ရေးသားခဲ့သော "An Investigation of the Laws of Thought" (1854) စာအုပ်တွင် ပါရှိသော symbolic logic အတွေးအခေါ်များမှ ဆင်းသက်လာခဲ့တာဖြစ်ပြီး

စာရေးဆရာကို ဂုဏ်ပြုသည့် အနေဖြင့် computer science နှင့် electronics များတွင် အသုံးပြုကြသော True / False တန်ဖိုးများကို Boolean Values လို့ ခေါ်ခဲ့ကြတာဖြစ်ပါတယ်။။

ဆယ်တန်းတွင် သင်ခဲ့ကြရသော AND, OR, NOT, NAND, NOR, XOR စသည့် logical operations များသည် Boolean Logic ပေါ်တွင် အခြေခံထားပါသည်။

Computer သည် လျှပ်စစ်ပစ္စည်းတစ်ခုသာဖြစ်ပြီး လျှပ်စစ်စနစ်တစ်ခုတွင် လျှပ်စစ်စီးဆင်းမှု ရှိ/မရှိ တစ်နည်းအားဖြင့် သတ်မှတ်ဗို့အားရှိ/မရှိဟူသော အခြေအနေနှစ်ခုသာ ရှိပါသည်။

ထိုအခြေအနေနှစ်ခုကို

on / off

1 / 0

True / False

စသဖြင့် Boolean Values အနေဖြင့် ဖော်ပြလေ့ရှိကြပါသည်။

Python မှာတော့ True နဲ့ False နှစ်ခုကိုသာ Boolean တန်ဖိုးအဖြစ် အသုံးပြုထားပါတယ်။

--- 

## 15. CRUD

data တွေမှာ အခြေခံ လုပ်ဆောင်ချက်လေးမျိုး ရှိပါတယ်။

1. Create

2. Read

3. Update

4. Delete

အထက်ပါလေးမျိုးကို စုပြီး CRUD ဆိုပြီး မှတ်သားထားနိုင်ပါတယ်။

--- 

ကိန့်ပြည့်နဲ့ ဒဿမကိန်းကို CRUD လုပ်ကြပါမယ်။

##### 1. Create

ကိန်းပြည့်နဲ့ ဒဿမကိန်းတွေ ဖန်တီးလိုပါက သင်္ချာမှာ သုံးခဲ့တဲ့အတိုင်း

```
1
2
3
1.5
2.5
3.5
```

အစသဖြင့် တန်ဖိုးတွေ တိုက်ရိုက်ရေးလိုက်ရုံပါပဲ။

တကယ်လို့ memory address ကို မှတ်ထားပေးမယ့် ကိုယ်စားပြုအမည်ပေးထားချင်ရင်တော့ assignment operator ကို အသုံးပြုနိုင်ပါတယ်။

```
x = 1
y = 1.5
```

--- 

##### 2. Read

data တွေ ရယူတာကို ဆိုလိုတာပါ။

access လုပ်တယ်လို့လည်း ပြောကြပါတယ်။

တန်ဖိုးတစ်ခုခုကို access လုပ်ချင်ရင် ကိုယ်စားပြုအမည်ကို ရေးလိုက်ရုံပါပဲ။

x လို့ရေးလိုက်ရင် ကွန်ပြူတာက x ထဲမှာ မှတ်ထားတဲ့လိပ်စာအတိုင်းသွားပြီး ရှာတဲ့အခါ 1 ကို တွေ့ပြီး access လုပ်ပေးမှာ ဖြစ်ပါတယ်။

--- 

##### 3. Update

အိမ်အဟောင်းကို ဖျက်ချပြီး အသစ်ပြန်ဆောက်သလိုမျိုး memory address တစ်ခုမှာ ရှိနှင့်ပြီးသား မူလ data ကို ဖျက်ပြီး အသစ်နဲ့ အစားထိုးတာကို ဆိုလိုပါတယ်။

Python မှာ ကိန်းပြည့်နဲ့ ဒဿမကိန်းတွေကို Update လုပ်ခွင့်မပေးထားပါဘူး။

--- 

##### Label

update လုပ်ခွင့်မပေးထားပေမယ့်လည်း ကိုယ်စားပြုအမည်ကတော့ လိပ်စာကတ်လိုမျိုး memory လိပ်စာကို မှတ်ထားရုံသာဖြစ်လို့ လိပ်စာအမျိုးမျိုး ပြောင်းလဲ ရေးသားနိုင်ပါတယ်။

--- 

##### Override

ရန်ကုန်နဲ့ မန္တလေးနေရာနှစ်ခုမှာ အိမ်နှစ်လုံးရှိတယ်ဆိုပါစို့။

လိပ်စာကတ်ကတော့ တစ်ခုတည်းပဲ ရှိတယ်ဆိုပါစို့။

မူလက ရန်ကုန်မှာနေလို့ လိပ်စာကတ်မှာ ရန်ကုန်လိပ်စာကို ရေးထားခဲ့ပေမယ့် နောက်ပိုင်းမှာ မန္တလေးကို ပြောင်းသွားခဲ့ရလို့ မူလလိပ်စာ ရန်ကုန်ဆိုတာကို ဖျက်ပြီး လိပ်စာအသစ်ပြောင်း ရေးလိုက်ပါတယ်။

လိပ်စာကတ်က မူလစက္ကူပြားဖြစ်နေပေမယ့် correction pen နဲ့ ဖုံးပြီး အသစ်ပြင်ရေးလိုက်လို့ လိပ်စာအဟောင်းပေါ်မှာ လိပ်စာအသစ်က ဖုံးအုပ်သွားပါတယ်။

အဟောင်းကို အသစ်က ဖုံးသွားတာကိုတော့ English လို Override ဖြစ်တယ်လို့ ခေါ်ပါတယ်။

--- 

```
x = 1
x = 3
```

ပထမ program မှာ x က 1 ရဲ့ memory address ကို မှတ်ထားပါတယ်။

ဒုတိယ program မှာတော့ 3 ရဲ့ memory address ကို ပြောင်းပြီး မှတ်သားလိုက်ပါတယ်။

1 နဲ့ 3 ဟာ အိမ်နှစ်လုံးလိုမျိုး memory address တစ်ခုစီနဲ့ တစ်နေရာစီမှာ ရှိနေကြပြီး x က လိပ်စာကိုပဲ မှတ်သားထားပါတယ်။

x က ခြံလည်းမဟုတ် အိမ်လည်းမဟုတ်ပဲ  အိမ်ရှိရာကို လမ်းညွှန်ပေးမယ့် လိပ်စာတွေကို ဖျက်လိုက် အသစ်ရေးလိုက်လုပ်နိုင်တဲ့ လိပ်စာကတ် / စက္ကူပြားပဲ ဖြစ်ပါတယ်။

ဒီအဆင့်မှာ ဒါတွေမသိလည်း ရပေမယ့် ခုလို ပြောပြလိုက်လို့ နည်းနည်း ရှုတ်သွားကောင်းရှုတ်သွားနိုင်ပေမယ့် နောင်တစ်ချိန် ပိုလွယ်စေဖို့ ထည့်ရေးလိုက်ရတာမျိုးပါ။

--- 

```
x = 1
x = 3
```

မူလက x က 1 ရဲ့ လိပ်စာကို ကိုယ်စားပြုလို့ ဒီအချိန်မှာ access လုပ်ခဲ့ရင် 1 ရှိတဲ့နေရာကို ရောက်သွားပါမယ်။

ဒုတိယ program ရေးပြီးတဲ့ အချိန်မှာတော့ လိပ်စာအသစ်ပြောင်းသွားလို့ လိပ်စာအသစ်အတိုင်းသွားခဲ့ရင်  3 ရှိတဲ့ နေရာကို ရောက်သွားပါမယ်။

x က 1 ဖြစ်နေရာကနေ 3 ဖြစ်သွားတယ်ဆိုတာမျိုး ယူဆပြီး Update  လုပ်လိုက်တယ်လို့ သဘောထားလိုက်လို့လည်း ရပါတယ်။

တကယ်လည်း ဒီလိုပဲ တွေးပြီး ရေးကြရတာပါပဲ။

တကယ့်အစစ်အမှန်ကတော့ ခြံတစ်ခုတည်း နေရာတစ်ခုတည်းမှာ အိမ်တွေကို ဖျက်လိုက် အသစ်ဆောက်လိုက်မဟုတ်ပဲ အသစ်အသစ်သော အိမ်တွေရဲ့ လိပ်စာတွေကိုသာ လိပ်စာကတ်ထဲမှာ ရေးလိုက်တာမျိုးပါ။

--- 

##### 4. Delete

ဖျက်ချင်ရင်  del ဆိုတဲ့ key စာလုံးကို သုံးပြီး ဖျက်လို့ရပါတယ်။

del ဆိုတာက delete ကို အဖျားဆွတ်ပြီး အမည်ပေးထားတာ ဖြစ်ပါတယ်။

x ကို ဖျက်ပါလို့ English လို ပြောချင်ရင် Delete x. လို့ ပြောရသလိုမျိုး

del x  ဆိုပြီး ရေးလိုက်ရင် လိပ်စာကတ်ကို ဖျက်သွားပါမယ်။

အိမ်တွေကတော့ memory ထဲမှာ ရှိနေပါဦးမယ်။

ဆိုလိုတာက တကယ်ဖျက်လိုက်တာ မဟုတ်ဘူးပေါ့။

ဘာကြောင့်လဲဆိုတော့ အိမ်တစ်ခု / ခြံတစ်ခုမှာ လိပ်စာကတ်တွေ အများကြီးရှိနိုင်လို့ပါပဲ။

--- 

လိပ်စာကတ်အများကြီးနဲ့ ဥပမာ ပေးရရင်

```
x = 1
y = x
z = x
```

အပေါ်က သုံးကြောင်းမှာ 1 ရဲ့ လိပ်စာတစ်ခုပဲ ရှိပြီး

ဒီတစ်ခုတည်းကိုပဲ x, y, z  သုံးခုလုံးမှာ မှတ်သားထားပါတယ်။

del x လို့ရေးလိုက်လို့ 1 ကို ဖျက်ပစ်လိုက်ရင် y နဲ့ z ဆိုတဲ့ တစ်ခြားလိပ်စာကတ်တွေကနေ လာခဲ့ရင် အိမ်မရှိတော့ပဲ ဖြစ်သွားပါလိမ့်မယ်။

ဒီလိုမျိုး မျှသုံးနေကြလို့ တကယ်မဖျက်ပေးတာပါ။

--- 

ကိုယ်စားပြုအမည်‌တွေဟာ လိပ်စာ မှတ်သားရုံသာဖြစ်လို့ လိပ်စာကတ်ကို မီးရှို့လို့ တကယ့်အိမ် မီးမလောင်သလိုမျိုး မှတ်ထားနိုင်ပါတယ်။

--- 

##### Garbage system

တကယ်လို့ data တစ်ခုကို ဖန်တီးထားပြီး ကိုယ်စားပြုအမည် မပေးထားတာမျိုး ၊ ပေးထားခဲ့ပြီး နောက်မှ ဖျက်ပစ်လိုက်တာမျိုး ဖြစ်သွားခဲ့ပြီး  နောင်တစ်ချိန်မှာလည်း ပြန်လည်အသုံးပြုထားတာမျိုး မရှိခဲ့ဘူးဆိုရင် ဖျက်သင့် မဖျက်သင့် အခြေအနေကြည့်ပြီး Python က အလိုအလျှောက် ဖျက်ပေးပါတယ်။

ဒီစနစ်ကို Garbage system လို့ အမည်ပေးထားပါတယ်။

အမှိုက်သိမ်းစနစ်ပေါ့။

ဒီတော့ del x လို့ ရေးတဲ့အခါ တကယ်ပျက်သွားတယ်လို့ ယူဆမယ်ဆိုရင်လည်း ရနိုင်ပါတယ်။

--- 

အခြေခံအဆင့်မှာ အမှတ်မှားမှာ စိုးရိမ်လို့ ထည့်ရေးပေးတာပါ။

တကယ်က CRUD ကို ဒီလိုမှတ်လည်း ရပါတယ်။

##### 1. Create

```
x = 1
y = 1.5
```

##### 2. Read

```
x
y
```

##### 3. Update

```
x = 1
x = 3
y = 1.5
y = 3.5
```

##### 4. Delete

```
del x
del y
```

--- 


## 16. Unicode character string, Control code


##### Unicode

uni က တူညီတာဖြစ်ပြီး code ကတော့ ကိုယ့်စားပြုတဲ့နံပါတ်တွေ ဖြစ်ပါတယ်။


##### Character

1. a, b, c, d နဲ့ ကကြီး ၊ ခကွေး လိုမျိုး အက္ခရာစာလုံးတွေ ၊

2. ပေါင်းနှုတ်မြှောက်စားလိုမျိုး သင်္ကေတတွေ

3. victory hand ✌️ လိုမျိုး စိတ်ခံစားချက်တွေ ဖော်ပြဖို့ သုံးတဲ့ သင်္ကေတတွေ

ဒါတွေအားလုံးကို character လို့ ခေါ်ပါတယ်။

မြန်မာလို့ အလွယ်မှတ်ရရင် character ဆိုတာ စာ ဒါမှမဟုတ် စာလုံးပေါ့။

နောက်တစ်ခုရှိတာက space character, new line character, Tab character, form feed character လိုမျိုး မမြင်ရတဲ့ စာလုံးတွေကလည်း စာထဲမှာ ပါဝင်ပါတယ်။

သာမန်စာလုံးတွေလို မမြင်နိုင်ပေမယ့်လည်း စာတွေကို အဆင်ပြေပြေ ပြသနိုင်ဖို့ control လုပ်ပေးနိုင်ကြပါတယ်။

##### String

အတန်းလိုက်ဖြစ်တယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

Character String ကြတော့ အတန်းလိုက်ဖြစ်နေတဲ့ စာလုံးတွေ တစ်နည်းအားဖြင့် စာတန်းပေါ့။

ဆီလျှော်အောင် ဘာသာပြန်ရရင်တော့ စာကြောင်းပေါ့။

---

##### New line character

စာတွေကို အောက်တစ်ကြောင်းဆင်းပြီး ပြသဖို့ တစ်နည်းအားဖြင့် စာကြောင်းအသစ်မှာ သွားပြဖို့ကို  new line character က လုပ်ဆောင်ပေးပါတယ်။

new line character ကို တွေ့ပြီဆိုရင် ကွန်ပြူတာက စာကြောင်းအသစ်မှာ ပြရမယ်ဆိုတာမျိုး နားလည်သွားပြီး အောက်တစ်ကြောင်းဆင်းပြီး ပြမှာပေါ့။

---

##### Line feed

new line character  ကို line feed လို့လည်း ခေါ်ပါတယ်။

line ကတော့ စာကြောင်းဖြစ်ပြီး feed ကတော့ အဆုံးသတ်တာဖြစ်ပါတယ်။

စာကြောင်းအဟောင်းကို အဆုံးသတ်တယ်ဆိုတာမျိုး line feed လို့ ခေါ်ကြသလို စာကြောင်းအသစ်ဖန်တီးတာဖြစ်လို့ new line character လို့လည်း ခေါ်ကြပါတယ်။

---

##### Form feed

form feed ကိုတော့ စာမျက်နှာတစ်ခု အဆုံးသတ်ပြီး အသစ်မှာ သွားပြဖို့အတွက် ဖန်တီးထားပါတယ်။

သူ့ကိုတော့ new form character ဆိုတာမျိုး မပြောကြပဲ form feed လို့ပဲ ခေါ်ကြပါတယ်။

---

##### Control code

line feed နဲ့ form feed တွေလိုမျိုး စာတွေကို control လုပ်ပေးဖို့ ဖန်တီးထားတဲ့ ကိုယ်စားပြု နံပါတ်တွေကို  character control code လို့ ခေါ်ကြပါတယ်။

delete character အပါအဝင် စုစုပေါင်း 65 ခု ရှိပါတယ်။

ယူနီကုတ်ကတော့ version 16.0 မှာ  စုစုပေါင်း 292_531 ရှိပါတယ်။

---

##### Space, Tab

space နဲ့ Tab ကိုတော့ လူတိုင်း သိကြမယ် ထင်ပါတယ်။

သိပြီးသားဆိုပေမယ့် Python ပရိုဂရမ် ရေးတဲ့အခါ သတိထားရမယ့်အချက်တွေ ရှိပါတယ်။

1. ကုတ်အစုအဝေးတွေ ဖန်တီးတဲ့အခါ ဖတ်ရလွယ်ဖို့အတွက် space လေးခုပဲ သုံးရမယ်ဆိုတာမျိုး သတ်မှတ်ထားပါတယ်။

2. Tab တစ်ခုမှာလည်း space လေးချက်စာ အကွာအဝေး ရှိရမယ်ဆိုတာမျိုး သတ်မှတ်ထားပါတယ်။ Tab တစ်ခုကိာ space နှစ်ခုစာ အကွာအဝေးကနေ ရှစ်ခုစာအထိ သတ်မှတ်နိုင်ပါတယ်။ font setting ထဲမှာ သတ်မှတ်လို့ ရပါတယ်။ computer အများစုကတော့ သုံးခုစာ အကွာအ‌ဝေးလို့ သတ်မှတ်ထားကြမယ် ထင်ပါတယ်။ Tab က ကွန်ပြူတာအလိုက် space လေးချက်စာ အကွာအဝေး ရှိ/မရှိ မသေချာနိုင်လို့ space ကိုပဲ လူတိုင်းသုံးကြပါတယ်။ Tab လည်း သုံးခွင့်ပေးထားတာပဲဆိုပြီး သုံးခဲ့ရင်တော့ မေတ္တာပို့ခံရပါလိမ့်မယ်။

3. program ရေးတဲ့အခါ ဖိုင်တစ်ခုထဲမှာ space နဲ့ tab ကို အတူတူရောပြီး ရေးထားခဲ့ရင် Python က ဘာသာမပြန်ပေးပါဘူး။ မရောထားရင်တော့ ဘာသာပြန်ပေးပါတယ်။ ဒါပေမယ့်လည်း အများနဲ့လုပ်ကြရတဲ့အခါကိုယ်က Tab နဲ့ ရေးထားပြီး တစ်ခြားသူရဲ့ space သုံးထားတဲ့ code တွေကို ကိုယ့်ဖိုင်ထဲကို copy ကူးပြီး ကြားညှပ်တာမျိုးဆိုရင် ဘာသာပြန်ပေးမှာ မဟုတ်သလို ကိုယ့် program ကိုလည်း တစ်ခြားသူက ယူသုံးခဲ့မယ်ဆိုရင် Tab နေရာမှာ space ပြန်ထားပြီး ပြန်ရေးနေရမှာဖြစ်လို့ မေတ္တာပို့ခံရပါလိမ့်မယ်။

4. အခုပြောခဲ့တဲ့ space နဲ့ Tab မရောရဘူးဆိုတာက ကုတ်အစုအဝေး ဖန်တီးတာကိုပဲ ဆိုလိုတာ ဖြစ်ပါတယ်။ ကုတ်အစုအဝေး ဖန်တီးကြတဲ့အခါ ဖတ်ရလွယ်ဖို့အတွက် နေရာလပ်တွေ ထားရတဲ့အခါ space လေးချက်သုံးဖို့ တိုက်တွန်းတာမျိုး ဖြစ်ပါတယ်။

---

##### Indent, Indentation

ကုတ်အစုအဝေး ဖန်တီးချိန်မှာ အသုံးပြုတဲ့ နေရာလပ်တွေကို English လို့ indent လို့ ခေါ်ကြပါတယ်။

နေရာလပ်ဖန်တီးတာကတော့ indentation ပေါ့။

English လိုဆိုရင်တော့ indentation ဆိုတာက creating space for code block ပေါ့။

---


## 17. Type casting

##### 1. Explicit

မြှုပ်ကွက်တွေမပါဝင်ပဲ ရှင်းရှင်းလင်းလင်းဖော်ပြထားတယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

ဥပမာပေးရရင် မိခင်က သားကို ရေခပ်စေချင်တဲ့အခါ explicit ပုံစံပြောချင်တယ်ဆိုရင်

"သားရေ သောက်ရေတစ်ခွက် ခပ်ပေးပါဦး။" လို့ ပြောရမှာ ဖြစ်ပါတယ်။


##### 2. Implicit

တိုက်ရိုက်မဟုတ်တာလို့ အဓိပ္ပါယ်ကောက်နိုင်ပါတယ်။

သွယ်ဝိုက်ပြီး ပြောတာမျိုးပေါ့။

ဥပမာပေးရရင် မိခင်က သားကို ရေခပ်စေချင်တဲ့အခါ implicit ပုံစံပြောချင်တယ်ဆိုရင်

"ရေဆာလိုက်တာ သားရေ။ " လို့ ပြောရမှာ ဖြစ်ပါတယ်။


##### 3. Type casting

type ဆိုတာက အမျိုးအစားပါ။

data type ဆိုရင်တော့ data အမျိုးအစားဖြစ်မှာပေါ့။

casting ဆိုတာက ပုံသွင်းတာကို ပြောတာပါ။

data အမျိုးအစားများကို ဖြစ်စေ ၊ တစ်ခြား အမျိုးအစားများကို ဖြစ်စေ မိမိအလိုရှိသလို ပုံသွင်းတာကို type casting လို့ ခေါ်ပါတယ်။


##### 4. Explicit type casting

type casting လုပ်တဲ့အခါ "သောက်ရေတစ်ခွက် ခပ်ပေးပါဦး" ဆိုတာမျိုး Python ကို တိုက်ရိုက် ခိုင်းလိုက်တာကို explicit type casting လို့ ခေါ်ပါတယ်။


##### 5. Implicit type casting

type casting လုပ်တဲ့အခါ ရေဆာတယ်လို့ ကိုယ့်ဘာသာ ညီးတွားပြီး သားသမီးကို သွယ်ဝိုက်တဲ့နည်းလမ်းတဲ့ ရေခပ်ခိုင်းသလိုမျိုး Python ကို သွယ်ဝိုက်ပြီး ခိုင်းတာကိုတော့ implicit type casting လို့ ခေါ်ပါတယ်။

ရေခပ်ခိုင်းလိုက်တာ မဟုတ်ပေမယ့် ရေဆာတယ်ဆိုတော့ အလိုက်တသိ ခပ်ပေးလိုက်ရသလိုမျိုး Python က အလိုက်တသိ ပြောင်းပေးလိုက်ရတာမျိုးပေါ့။

---


## 18. function

မြင်သာအောင် ပြောရရင် မျက်စိမရှုတ်စေဖို့ code တွေကို အမည်တစ်ခုပေးပြီး စုစည်းထားတာပါပဲ။

##### 1. integer function ( int )

တစ်ခြား data အမျိုးအစားတွေကို ကိန်းပြည့်ပြောင်းဖို့အတွက် ကြိုတင်ရေးသားထားတဲ့ code တွေ ရှိပါတယ်။

integer အဖြစ် ပြောင်းလဲပေးမှာဖြစ်လို့ မှတ်ရလွယ်‌အောင် int လို့ပဲ အမည်ပေးထားကြပါတယ်။

ဒီအမည်ကို ခေါ်သုံးလိုက်ရင် နောက်ကွယ်မှာ ရေးထားတဲ့ code  တွေက အလုပ်လုပ်သွားမှာ ဖြစ်ပါတယ်။

---

ခေါ်တဲ့အခါ int ဆိုပြီး အမည်ပဲရေးလိုက်တာနဲ့  int() ဆိုပြီး ဝိုက်ကွင်းနဲ့ တွဲပြီး ခေါ်တာဆိုပြီး နှစ်မျိုးရှိပါတယ်။

int လို့ အမည်သီးသန့်ရေးလိုက်ရင် နောက်ကွယ်က code တွေ အလုပ်မလုပ်ပါဘူး။

ဝိုက်ကွင်းကို နောက်မှာကပ်ပြီး ရေးလိုက်မှသာ နောက်ကွယ်က code တွေ အလုပ်လုပ်မှာပါ။

ဝိုက်ကွင်းတပ်ပြီး ခေါ်လိုက်တာကို calling a function လို့ ခေါ်ပါတယ်။

---

x = 1.6

ဒီ program မှာ x ဟာ floating point number ဖြစ်တဲ့ 1.6 ကို ကိုယ်စားပြုပါတယ်။

ကိန်းပြည့်ပြောင်းချင်ရင် int(x) လို့ ရေးလိုက်ရုံပါပဲ။

ကိန်းပြည့်ပြောင်းတဲ့အခါ decimal point ပါတဲ့ အစိတ်အပိုင်းကို ဖြတ်ချလိုက်တာဖြစ်လို့ 1 ပဲ ကျန်ခဲ့ပါလိမ့်မယ်။

---

```
x = 1.6
y = int(x)
```

ဒီ program မှာဆိုရင် integer  function က 1 ကို ထုတ်ပေးမှာဖြစ်လို့

y = 1 လို့ ရေးလိုက်သလို ဖြစ်သွားပါလိမ့်မယ်။

ရှိပြီးသား 1.6 ကို ပြင်လိုက်တာမျိုးမဟုတ်ပဲ သူ့ရဲ့ copy တန်ဖိုးကို အသုံးပြုပြီး ကိန်းပြည့်အသစ်တစ်ခု ဖန်တီးလိုက်တာမျိုးပါ။

integer function ဟာ တိကနဲ့ ဖြတ်ချတာဖြစ်လို့ truncate လုပ်တယ်လို့ ခေါ်ပါတယ်။

---

##### 2. round function

တိကနဲ ဖြတ်မချပဲ လိုတိုး/ ပိုလျော့လုပ်ပြီး ညီအောင်ညှိတာကို round လုပ်တယ်လို့ ခေါ်ပါတယ်။

```
x = 1.6
y = round(x)
```

ဒီ program မှာဆိုရင် round function က 2 ကို ထုတ်ပေးမှာ ဖြစ်ပါတယ်။

ဘာကြောင့်လဲဆိုတော့ 1.6 က 2 နဲ့ ပိုနီးစပ်လို့ပါ။

လိုတိုး/ ပိုလျော့ကို ဘယ်လိုတွက်လဲဆိုတော့ 1.5 ကနေစပြီး 2 လို့ ယူဆပါတယ်။

သူ့ထက်ငယ်တဲ့ 1.49 ကို round လုပ်ရင်တော့ 1 ရပါမယ်။

အနီးစပ်ဆုံး ကိန်းပြည့်တန်ဖိုးကို ယူလိုက်တာမျိုးပေါ့။

---

အနှစ်ချုပ်ရရင်တော့ တစ်ခြား data အမျိုးအစားတွေကို အကြောင်းအမျိုးမျိုးကြောင့် ကိန်းပြည့်ပြောင်းဖို့ လိုအပ်လာတဲ့အခါ

decimal point ပါတဲ့ အစိတ်အပိုင်းကို တိကနဲ ဖြုတ်ချချင်ရင် int ကို သုံးနိုင်ပြီး

နီးစပ်ရာတန်ဖိုးယူစေချင်ရင်တော့ round ကို သုံးနိုင်ပါတယ်။

English လို ဆိုရင်တော့ truncate လုပ်ဖို့အတွက် int function ကို သုံးရမှာဖြစ်ပြီး

round လုပ်ချင်ရင်တော့ round function ပေါ့။

---

##### 3. direct type casting / explicit type casting

integer function, round function စသဖြင့်  တိုက်ရိုက်ရေးပြီး data အမျိုးအစားပြောင်းတာကို direct type casting လို့ ခေါ်ပါတယ်။

ဒါလုပ်ပါဆိုတာမျိုး ဒဲ့ရေးလိုက်တာဖြစ်လို့ explicit type casting လို့ ခေါ်ကြပါ‌တယ်။

---


## 19. Operators (43)

##### 1. Operation

တစ်ခုခုလုပ်တာကို ပြောတာပါ။

ခွဲစိတ်မှုပြုလုပ်ခြင်း ၊ စစ်ဆင်ရေးပြုလုပ်ခြင်း ၊  ပေါင်းခြင်း ၊ နှုတ်ခြင်း စတာတွေကို operation လို့ ယူဆနိုင်ပါတယ်။

လက်တွေ့မှာလည်း ခွဲစိတ်မှုကို surgery operation ၊ ပေါင်းခြင်းကိုတော့ additional operation လို့ ရေးကြပါတယ်။

---

##### 2. Operator

သင်္ချာနည်းအရဆိုရင် operation တစ်ခုခုလုပ်ပေးမယ့် သင်္ကေတတွေလို့ မှတ်သားထားနိုင်ပါတယ်။

---

##### 3. Operand

operation မှာ ပါဝင်မယ့် တန်ဖိုးတွေလို့ပဲ မှတ်ထားပေးပါ။

---

##### 4. Operation & Operator & Operand

ဗိုက်ခွဲမွေးတဲ့ operation လုပ်ကြမယ်ဆိုပါစို့။

ခွဲစိတ်ဆရာဝန်က operator ဖြစ်ပြီး လူနာကတော့ operand ဖြစ်ပါမယ်။

---

##### 5. `1 + 2` တစ်နဲ့ နှစ်ကို ပေါင်းမယ်ဆိုပါစို့။

operation က additional operation ဖြစ်ပါမယ်။

operator က အပေါင်းဖြစ်ပါမယ်။

operand နှစ်ခုကတော့ တစ်နဲ့နှစ် ဖြစ်ပါမယ်။

---

##### 6. Left operand

`1 + 2` မှာ operator ရဲ့ ဘယ်ဘက်က တန်ဖိုး တစ်ကို left operand လို့ ခေါ်ပါတယ်။

operand လို့ အလွယ်ပြောလိုက်လို့ ရနိုင်‌ပေမယ့် ဘယ်ဘက်မှာရှိတဲ့အတွက် left operand ဆိုတာမျိုး တိတိကျကျ မှတ်ရပါမယ်။

---

##### 7. Right operand

ညာဘက်က တန်ဖိုးနှစ်ကတော့ operator ရဲ့ ညာဘက်မှာရှိတော့ right operand ပေါ့။

---

##### 8. Unary operator

unary ဆိုတာက လက်တင်ဘာသာစကားပါ။

English လို one လို့ အဓိပ္ပါယ်ရပါတယ်။

အလုပ်လုပ်ဖို့အတွက် operand တစ်ခုတည်း လိုအပ်တာကို unary operator လို့ ခေါ်ပါတယ်။

ပိုပြီးတိကျချင်ရင် right operand တစ်ခုတည်းနဲ့ အလုပ်လုပ်တယ်လို့ မှတ်ထားနိုင်ပါတယ်။

---

##### 9. အမျိုးအစားသိရုံနဲ့ အသုံးပြုတတ်ရမည်။

မိမိလုံးဝမသိတဲ့  operator တစ်ခုခုကို တွေ့ရတဲ့အခါ

တန်ဖိုးကို ဘယ်မှာထားရမလား။

ညာမှာထားရမှာလား။

left operand တစ်ခုတည်းလား။

right operand တစ်ခုတည်းလား။

စသဖြင့် ဝေဝါးမနေပဲ မသင်ရသေးလည်း သုံးတတ်ရပါမယ်။

---

##### 10. Example.1

မသိလည်း သုံးတတ်ရမယ်ဆိုတာနဲ့ ပတ်သတ်ပြီး ဥပမာပေးရရင်

`x = 0b0000_0000_0000_0000_0000_0000_0000_0101`

အထက်ပါ binary တန်ဖိုးတွေကို zero နေရာမှာ one , one နေရာမှာ zero ဆိုပြီး ဆန့်ကျင်ဘက်တန်ဖိုးတွေအဖြစ် ပြောင်းလဲချင်ပါတယ်။

လိုချင်တဲ့ ရလဒ်က ခုလိုမျိုးပါ။

`1111 1111 1111 1111 1111 1111 1111 1010`

ဒီလိုပြောင်းချင်ရင် bitwise NOT  operator ( ~ )ကို အသုံးပြုနိုင်ပါတယ်။

သူက unary operator အမျိုးအစားဖြစ်တယ်လို့ သိထားတယ်ဆိုပါစို့။

ဒါဆိုရင်

```
~ x လို့ ရေးရမှာလား။
x ~ လို့ ရေးရမှာလား။
x ~ x လို့ ရေးရမှာလား။
```

စသဖြင့် ဝေဝါးမနေပဲ ဘာရေးရမလဲ တိတိကျကျ ‌သိနေရပါမယ်။

---

##### 11. Example.2

unary minus ကို မသင်ရသေးပေမယ့် သုံးရတော့မယ်ဆိုပါစို့။
```
- 1

1 -

2 - 1
```

စသဖြင့် ဝေဝါးနေလို့ မရပါဘူး။

right operand တစ်ခုတည်းရှိရင် unary minus ဆိုတာမျိုး သိထားရပါမယ်။

---

##### 12. binary operator

binary ဆိုတာက လက်တင်ဘာသာစကားပါ။

English လို two လို့ အဓိပ္ပါယ်ရပါတယ်။

operand နှစ်ခုနဲ့ အလုပ်လုပ်တာကို binary operator လို့ ခေါ်ပါတယ်။

ပိုပြီးတိကျချင်ရင် left operand, right operand နှစ်ခုနဲ့ အလုပ်လုပ်တယ်လို့ မှတ်ထားနိုင်ပါတယ်။

တစ်ခုသတိထားရမှာက အပေါင်းနှစ်ခု ၊ အနှုတ်နှစ်ခု ရှိနေတဲ့ ပြသနာပါ။

---

##### 13. unary plus ( positive )

`+1` မှာ ပါတဲ့ အပေါင်းက unary plus ဖြစ်ပါတယ်။

အပေါင်းကိန်းအဖြစ် သတ်မှတ်ဖို့ သုံးပါတယ်။

positive ဖြစ်ကြောင်း သတ်မှတ်တာဖြစ်လို့ function အမည်ကို pos လို့ ပေးထားပါတယ်။

`+1` လို့ ရေးလိုက်ရင် pos လို့ အမည်ပေးပြီး ကြိုရေးထားတဲ့ program တွေ အလုပ်လုပ်ပါမယ်။

---

##### 14. binary plus ( addition operator )

`1 + 2` မှာပါတဲ့ အပေါင်းကတော့ binary plus ဖြစ်ပါတယ်။
addition operation လုပ်မှာဖြစ်လို့ add လို့ အမည်ပေးထားတာပါ။

`1 + 2` လို့ ရေးလိုက်ရင် add လို့ အမည်ပေးပြီး ကြိုရေးထားတဲ့ နောက်ကွယ်က program တွေ အလုပ်လုပ်ပါမယ်။

---

##### 15. unary minus ( negative )

`-1` ဆိုရင် neg လို့ အမည်ပေးပြီး စုစည်းထားတဲ့ program တွေ အလုပ်လုပ်ပါမယ်။

negative ဖြစ်ကြောင်း သတ်မှတ်ပေးတာဖြစ်လို့ နောက်ကွယ်က program ကို neg လို့ပဲ အမည်ပေးထားတာပါ။

---

##### 16. binary minus ( subtraction operator )

`2 - 1` မှာ ပါတဲ့ သင်္ကေတက  binary minus ပါ။

subtraction operator တစ်နည်းအားဖြင့် နှုတ်တာပေါ့။

Subtraction လုပ်တာဖြစ်လို့ နောက်ကွယ်က program ကို sub လို့ အမည်ပေးထားပါတယ်။

---

##### 17. unary plus & binary plus ( pos & add )

သင်္ကေတတူပေမယ့် positive နဲ့ addition ဆိုပြီး နှစ်ခု ကွဲနေကြပါတယ်။

Python ဟာ အပေါင်းကို တွေ့ရတဲ့အခါ

right operand တစ်ခုတည်းပါခဲ့ရင် positive function ကို အလုပ်လုပ်ခိုင်းတယ်လို့ ယူဆမှာဖြစ်ပြီး

left operand လည်း ပါခဲ့ရင်တော့ add function ကို အလုပ်လုပ်ခိုင်းတယ်လို့ ယူဆမှာဖြစ်ပါတယ်။

operand အရေအတွက်နဲ့ ခွဲခြားလိုက်တာမျိုးပါပဲ။

---

##### 18. unary minus & binary minus ( neg & sub )

သင်္ကေတတူပေမယ့် positive နဲ့ addition ကွဲနေကြသလို negative နဲ့ subtraction ဆိုပြီးလည်း ကွဲနေကြပါတယ်။

right operand တစ်ခုတည်းပါရင် negative function လို့ ယူဆမှာဖြစ်ပြီး  neg လို့ အမည်ပေးထားတဲ့ program ကို အလုပ်လုပ်ပါမယ်။

left operand လည်း ပါခဲ့ရင်တော့ sub function ဆိုတာမျိုး ခွဲခြားပြီး လုပ်ပေးပါတယ်။

---

##### 19. ternary operator

ternary ဆိုတာကလည်း လက်တင်စကားပါပဲ။

English လို three လို့ အဓိပ္ပါယ်ရပါတယ်။

operand သုံးခုနဲ့ အလုပ်လုပ်တာကို ternary operator လို့ ခေါ်ပါတယ်။

ပိုပြီးတိကျချင်ရင် left operand, middle operand, right operand ဆိုပြီး operand သုံးခုနဲ့ အလုပ်လုပ်တယ်လို့ မှတ်ထားနိုင်ပါတယ်။

control flow သင်ပြီးမှသာ ရှင်းပြလို့ရမှာဖြစ်လို့ လောလောဆယ် ဒီလောက်သိထားရင် ရပါပြီ။

---


## 20. Addition, Type casting 


##### 1. Unary plus & Addition & Concatenation ( + )


`+1 ` ဆိုရင် unary plus လို့ သိရပါမယ်။

အလုပ်လုပ်မယ့် code တွေက positive function ထဲက code တွေဖြစ်ပါတယ်။

အပေါင်းကိန်းဖြစ်ကြောင်း ဖော်ပြရုံပါပဲ။

1 ဆိုပြီး unary plus ကော unary minus ကော မထည့်ထားခဲ့ရင် +1 လို့ ယူဆပါမယ်။

---

`2 + 1` ဆိုရင် binary plus တစ်နည်းအားဖြင့် addition operator လို့ သိရပါမယ်။

အလုပ်လုပ်မယ့် code တွေက add function ထဲက code တွေ ဖြစ်ပါမယ်။

`3` ဆိုတဲ့ တန်ဖိုးအသစ်ကို ထုတ်ပေးပါမယ်။

---

`"a" + "b"` ဆိုရင် concatenation operator လို့ သိရပါမယ်။

အလုပ်လုပ်မယ့် code တွေက string နဲ့ သက်ဆိုင်တဲ့ add function ထဲက code တွေဖြစ်ပါတယ်။

`"ab"` ဆိုတဲ့ တန်ဖိုးအသစ်ကို ထုတ်ပေးပါမယ်။

`"1" + "2"` ဆိုရင်တော့  `"12"` ကို ထုတ်ပေးပါမယ်။

---

##### 2. integer addition & float addition & string addition

`1 + 2` နဲ့ `1.0 + 2` က မတူညီကြပါဘူး။

`1 + 2` ဆိုရင် integer နဲ့ သက်ဆိုင်တဲ့ add function အလုပ်လုပ်မှာဖြစ်ပြီး

`1.0 + 2` ဆိုရင်တော့ float နဲ့ သက်ဆိုင်တဲ့ add function အလုပ်လုပ်မှာ ဖြစ်ပါတယ်။

`"1" + 2` ဆိုရင်တော့ string နဲ့ သက်ဆိုင်တဲ့ add function အလုပ်လုပ်မှာ ဖြစ်ပါတယ်။

left operand ရဲ့ အမျိုးအစားပေါ်မူတည်ပြီး ကွဲပြားသွားမှာ ဖြစ်ပါတယ်။

---

##### 3. addition of difference value

တန်ဖိုးမတူရင် computer ထဲမှာ သိမ်းပုံစံ မတူပါဘူး။

ဒါကြောင့် အတူတကွ operation လုပ်မယ်ဆိုရင် အဆင်မပြေနိုင်ပါဘူး။

`1 + 1.5` ဆိုပြီး မတူတဲ့ data နှစ်ခုကို ပေါင်းခိုင်းလို့ မရပါဘူး။

ပေါင်းချင်ရင် တူအောင် အရင်ပြောင်းရပါတယ်။

ပြောင်းတဲ့အခါ ရွေးချယ်စရာ သုံးခုရှိပါတယ်။

--- 

##### 4. choice.1 ( truncation )

int function ကို သုံးပြီး 1.5 ထဲက decimal point ပါတဲ့ အစိတ်အပိုင်းကို ဖြတ်ချလို့ရပါတယ်။

truncate လုပ်ဖို့ ရွေးခဲ့မယ်ဆိုရင်

`1 + 1.5` ကနေ `1 + 1` ဖြစ်သွားပြီး အဖြေကတော့ 2 ဖြစ်ပါမယ်။

--- 

##### 5. choice.2 ( round  )

round function ကို သုံးပြီး `1.5` ရဲ့ အနီးစပ်ဆုံးတန်ဖိုးကို တွက်ထုတ်ခိုင်းလို့ရပါတယ်။

round လုပ်ဖို့ ရွေးခဲ့မယ်ဆိုရင်

`1 + 1.5` ကနေ `1 + 2` ဖြစ်သွားပြီး အဖြေကတော့ `3` ဖြစ်ပါမယ်။

--- 

##### 6. choice.3 ( float )

အပေါ်နှစ်ခုလိုမျိုး ကိန်းပြည့်အဖြစ်တူသွားအောင် မလုပ်တော့ပဲ left operand ကို float အဖြစ် ပြောင်းခိုင်းလိုကိပြီး အတူတူ float ဖြစ်အောင် လုပ်လို့လည်း ရပါသေးတယ်။

left operand တစ်ကို float ပြောင်းခဲ့ရင် `1.0` ကို ထုတ်ပေးပါမယ်။

`1 + 1.5` ကနေ `1.0 + 1.5` ဖြစ်သွားပြီး အဖြေကတော့ `2.5` ဖြစ်ပါမယ်။

--- 

##### 7. best choice

စာဖတ်နေရင်း အပေါ်သုံးခုမှာ ဘယ်နည်းက ပိုကောင်းမယ်ဆိုတာမျိုး တွေးခဲ့မိပါသလား။

တွေးမိခဲ့ရင် ဒီလိုစိတ်ကို ဖျောက်ရပါမယ်။

programming မှာ ပိုကောင်းတဲ့ နည်းဆိုတာ မရှိပါဘူး။

ပိုသင့်တော်တဲ့ နည်းပဲရှိပါတယ်။

ကိန်းပြည့်လိုချင်သူက ပထမနည်းနှစ်ခုကို ရွေးရမှာဖြစ်ပြီး ဒသမကိန်းလိုချင်ရင်တော့ တတိယနည်းကို သုံးရမှာဖြစ်ပါတယ်။

--- 

##### 8. precision value

```

1 + 1.5

choice.1  --->  1 + int(1.5)     -->  1 + 1        -->   2

choice.2  --->  1 + round(1.5)   -->  1 + 2        -->   3

choice.3  --->  float(1) + 1.5   -->  1.0 + 1.5    -->   2.5

```

တတိယအဖြေက ပိုတိကျတာဖြစ်လို့ အထူးအခြေအနေမဟုတ်ခဲ့ရင် လူအများစုက တတိယနည်းလမ်းကိုပဲ ရွေးချယ်လေ့ ရှိကြပါတယ်။

--- 

##### 9. readability

လူအများစုဟာ အဖြေတိကျချင်လို့  တတိယနည်းလမ်းကိုပဲ ရွေးချယ်ကြပါတယ်။

`1 + 1.5` ဆိုတာမျိုး သင်္ချာတွက်သလို ရေးရုံနဲ့ အဖြေ `2.5` ရတာနဲ့

`float(1) + 1.5` လို့ ရေးပြီးမှ အဖြေ `2.5` ရတာ ဘယ်ဟာက ပိုပြီး မျက်စိရှုတ် သက်သာမယ် ထင်ပါသလဲ။

မျက်စိရှုတ်သက်သာစေဖို့အတွက်  int နဲ့ float ပေါင်းခဲ့ရင် တတိယနည်းကို အလိုလို သုံးပေးထားပါတယ်။

computer မှာ အဆင်ဆင်ပြေပြေ အလုပ်လုပ်နိုင်အောင် Python က နောက်ကွယ်မှာ အလိုအလျောက် ပြောင်းပေးတာမျိုးပေါ့။

Python မဟုတ်တဲ့ programming language မှာ ပေါင်းချင်ရင်တော့ ကိုယ့်ဘာသာ ပြောင်းရပါတယ်။

readability ဖြစ်ဖို့ ၊ အလွယ်တကူနားလည်ဖို့ ဖန်တီးထားတာဖြစ်လို့ Python လေ့လာတဲ့အခါ ကျော်ထားတဲ့ အဆင့်တွေကို မြင်ဖို့ လိုအပ်ပါတယ်။

Python မှာ `1 + 1.5` လို့ ရေးလိုက်လို့ ရပါတယ်။

အဖြေလည်း 2.5 ဆိုပြီး တိတိကျကျရပါတယ်။

ဒါပေမယ့် int နဲ့ float  ဆိုတဲ့ မတူညီတဲ့ အမျိုးအစားနှစ်ခုကို ပေါင်းလိုက်တာမဟုတ်ပဲ အားလုံးကို float ဖြစ်ပြီး တူသွားအောင် တတိယနည်းကို မိမိအစား Python က သုံးပေးသွားတယ်ဆိုတာမျိုး ကြားထဲက အဆင့်တွေကို မြင်နိုင်နေရပါမယ်။

--- 

##### 10. implicit type casting

`1 + 1.5` လို့ ရေးလိုက်တဲ့အခါ `float(1) + 1.5` လို့ နောက်ကွယ်မှာ ပြောင်းပေးမှာဖြစ်ပါတယ်။

အမေက ရေဆာတယ်ပြောတဲ့အခါ ရေမခပ်ခိုင်းပေမယ့် ခပ်ပေးလိုက်ရသလိုမျိုး

float ပြောင်းပါလို့ မရေးခဲ့ပေမယ့် data အမျိုးအစားမတူလို့ တူသွားအောင် Python က နောက်ကွယ်ကနေ ပြောင်းပေးလိုက်ရပါတယ်။

ရေဆာတယ်လို့ ပြောတာက သွယ်ဝိုက်တဲ့ နည်းလမ်းနဲ့ ရေခပ်ခိုင်းတာဖြစ်သလို

`1 + 1.5` လို့ ရေးလိုက်တာကလည်း choice.3 ကို သွယ်ဝိုက်တဲ့နည်းနဲ့ ရွေးခိုင်းလိုက်တာပါပဲ။

ဒါကိုတော့ implicit type casting လို့ ခေါ်ပါတယ်။

--- 


## 21. Operator precedence

အကြောင်းအမျိုးမျိုးကြောင့် operator တွေကို အတူတကွ ပေါင်းစပ်ပြီး အသုံးပြုကြရတဲ့အခါ ရှုတ်ထွေးမသွားပဲ အစီအစဉ်တကျ ဆက်ပြီးအလုပ်လုပ်နိုင်စေဖို့အတွက် သတ်မှတ်ပေးထားတဲ့ စည်းမျဉ်းဆိုပြီး ယူဆနိုင်ပါတယ်။

ကားတွေမတိုက်အောင် ဘယ်မောင်းနဲ့ ညာမောင်း ၊ ယာဉ်စည်းကမ်း ၊ လမ်းစည်းကမ်း သတ်မှတ်ကြသလို‌ပေါ့။

--- 

မြင်သာအောင် ပြောရရင်

`1 + 2 * 3` ကို ဖြေရှင်းတဲ့အခါ ရွေးချယ်စရာ နည်းလမ်းနှစ်ခုရှိပါတယ်။

```
choice.1  ( ပေါင်းပြီး မြှောက် )

>>  1 + 2 * 3
>>  3 * 3
>>  9

choice.2  ( မြှောက်ပြီး ပေါင်း )

>>  1 + 2 * 3
>>  1 + 6
>>  7

```

အထက်ပါအတိုင်း `1 + 2 * 3` ကို ဖြေရှင်းတဲ့အခါ

အမြှောက်ကို ဦး‌စားပေးပြီး ဖြေရှင်းတာနဲ့ အပေါင်းကို ဦးစားပေးပြီး ဖြေရှင်းတာ အဖြေတွေ မတူနိုင်ပါဘူး။

ပေါင်းပြီး မြှောက်ခဲ့ရင် `9` ရမှာဖြစ်ပြီး မြှောက်ပြီး ပေါင်းခဲ့ရင် `7` ရမှာဖြစ်ပါတယ်။

ဘယ်သူ့ကို ဦး‌စားပေးပြီး အရင်ဖြေရှင်းမလဲဆိုတာကို precedence လို့ ခေါ်ပါတယ်။

အပြည့်အစုံကတော့ operator precedence ပေါ့။

--- 

ဦးစားပေးရွေးချယ်တဲ့ နေရာမှာ အမှန်အမှားဆိုတာမျိုး မရှိပဲ မိမိကြိုက်နှစ်သက်ရာ နည်းလမ်းကို ရွေးချယ်နိုင်ပါတယ်။

ကြိုက်နှစ်သက်ရာနည်းလမ်းကို ရွေးချယ်နိုင်တာဖြစ်လို့ programming language တွေကို ဖန်တီးခဲ့ကြသူတွေကလည်း ကိုယ်အဆင်ပြေမယ်ထင်ရာ ရွေးခဲ့ကြပါတယ်။

ဒါကြောင့် programming language မတူခဲ့ရင် precedence တွေလည်း ကွဲပြား‌သွားနိုင်တယ်ဆိုတာမျိုး နားလည်ထားရပါမယ်။

တစ်ခုကောင်းတာက ဘယ်သူတွေ ဘယ်နည်းလမ်းကိုပဲ ရွေးခဲ့ကြပါစေ Python ကတော့ သင်္ချာမှာ အသုံးပြုနေတဲ့ စံနှုန်းအတိုင်းပဲ ဖန်တီးခဲ့ပါတယ်။

ကျောင်းမှာသင်ခဲ့ရတဲ့အတိုင်း Python မှာ အလုပ်လုပ်ပါတယ်။

--- 

Exercise.1

Python ဟာ ကျောင်းမှာ သင်ခဲ့ရတဲ့အတိုင်းလိုက်နာတယ်ဆိုရင် အမြှောက်နဲ့ အပေါင်းမှာ ဘယ်အရာကို ဦးစားပေးမယ် ထင်ပါသလဲ။

--- 

Exercise.2

1 + 2 * 3 ကို ဖြေရှင်းတဲ့အခါ ဘယ်နည်းကို ရွေးမယ်ထင်ပါသလဲ။

--- 


## 22. Arithmetic operators (9)

သင်္ချာဆိုင်ရာ လုပ်ဆောင်ချက်တွေအတွက် ဖန်တီးထားတဲ့ ပေါင်းနှုတ်မြှောက်စားတွေကို ‌ပြောတာဖြစ်ပါတယ်။

စုစုပေါင်းကိုးခုရှိပါတယ်။

1. Exponentiation
2. Unary minus
3. Unary plus
4. Multiplication
5. Division
6. Floor Division
7. Modulus
8. Addition
9. Subtraction

ဒီအမည်တွေ အလွတ်ရထားရပါမယ်။

မခက်ပါဘူး။

"e u မြှောက်စား ပေါင်းနှုတ်" ဆိုပြီး မှတ်လိုက်ရင် ကိုးခုလုံးရပါပြီ။

- e က exponent
- u က unary plus နဲ့ unary minus
- အမြှောက်က အမြှောက်ပါပဲ။
- အစားကတော့  Division, Floor Division နဲ့ Modulus ဆိုပြီး သုံးခုရှိပါတယ်။
- အပေါင်းအနှုတ်ကတော့ အပေါင်းအနှုတ်ပါပဲ။

လိုရင်းပြောရရင်  "e u မြှောက်စား ပေါင်းနှုတ်" ဆိုပြီး နေ့တိုင်း ဆယ်ခါလောက်ရွတ်ပါ။

နာမည်လေးတောင် အလွတ်မရတဲ့သူတွေကို စာမသင်ချင်ပါဘူး။

ဒါကြောင့် နာမည်တွေအလွတ်ရပြီဆိုမှသာ နောက်သင်ခန်းစာကို ဆက်ပြီး ဖတ်ပါ။

---

operator က စုစုပေါင်း အခုငါးဆယ်လောက်ရှိတာဖြစ်ပြီး အားလုံးကို အလွတ်ရနေရမှာ ဖြစ်ပါတယ်။

များတယ်လို့ ပြောလို့ရပေမယ့် အခုတောင် ကိုးခုရသွားပြီဖြစ်သလို assignment operator 15 ခုကလည်း အလိုလိုရသွားမှာဖြစ်လို့ 24 ခု ရသွားပြီလို့တောင် ပြောလို့ရပါတယ်။

---

#### Arithmetic operator ကိုးမျိုး

##### 1. Exponentiation

ထပ်ကိန်းတင်တာကို ပြောတာဖြစ်ပါတယ်။

ထပ်ကိန်းဆိုတာက အကြိမ်ကြိမ် အထပ်ထပ် မြှောက်မယ့် အရေအတွက် ဖြစ်ပါတယ်။

မြင်သာအောင်‌ ပြောရရင် နှစ်ရဲ့ ထပ်ကိန်းဟာ ရှစ်ဖြစ်ခဲ့မယ်ဆိုရင် နှစ်ကို ရှစ်ကြိမ်မြှောက်ရမှာ ဖြစ်ပါတယ်။

သင်္ကေတက asterisk `**` နှစ်ခုပူး ဖြစ်ပါတယ်။ 

---

အသုံးပြုနည်းက `base ** exponent` ဖြစ်ပါတယ်။

base ဆိုတာက မူလရှိထားတဲ့ တန်ဖိုးပါ။

exponent ကတော့ ထပ်ကိန်း ဖြစ်ပါတယ်။

---

ဒါကတော့ နှစ် ရှစ်ထပ် ဖြစ်ပါတယ်။

`2 ** 8 `

နှစ်ရှစ်ထပ်ကို တွေ့တဲ့အခါ  စိတ်ထဲမှာ အောက်ပါအတိုင်း နှစ်ကို ရှစ်ကြိမ် အထပ်ထပ် မြှောက်ထားတယ်ဆိုတာမျိုး ပုံဖော်နိုင်ရပါမယ်။

`2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 `

---

##### 2. Unary minus

ရှင်းပြခဲ့ပြီးသားဖြစ်ပါတယ်။

---

##### 3. Unary plus

ရှင်းပြခဲ့ပြီးသားဖြစ်ပါတယ်။

---

##### 4. Multiplication

အကြိမ်ကြိမ်‌ပေါင်းတာ ဖြစ်ပါတယ်။

နှစ် အမြှောက် ရှစ် ဆိုရင် နှစ်ကို ရှစ်ကြိမ်ပေါင်းရမှာ ဖြစ်ပါတယ်။

နှစ်ကို ရှစ်ခါပေါင်းရင် 16 ရမှာဖြစ်ပါတယ်။

Python မှာ `နှစ် အမြှောက် ရှစ်` ကို `2 * 8` ဆိုပြီး ရေးပါတယ်။

သင်္ကေတက asterisk တစ်ခု ဖြစ်ပါတယ်။

---

##### 5. Division

အစားကို ပြောတာပါ။

အမြှောက်နဲ့ ဆန့်ကျင်ဘက်ဖြစ်ပါတယ်။

သင်္ကေတက forward slash ` / ` ဖြစ်ပါတယ်။

slash အမှတ်အသားက ရှေ့ကို ယိုင်နေလို့ forward slash လို့ ပြောတာ ဖြစ်ပါတယ်။

နောက်ကို ယိုင်တာနဲ့ မှားတတ်ပါတယ်။

---

`16 / 2 ` ဆိုပြီး စားခိုင်းတဲ့အခါ 16 ရဖို့ 2 ကို ဘယ်နှစ်ကြိမ်ပေါင်းရမလဲ တွက်ခိုင်းတာ ဖြစ်ပါတယ်။

`16` ရဖို့အတွက် နှစ်ကို ရှစ်ကြိမ်ပေါင်းဖို့ လိုအပ်တာဖြစ်လို့ အဖြေက `8` ဖြစ်ပါမယ်။

---

##### 6. Floor Division

floor ဆိုတာက ကြမ်းပြင်ကို ပြောတာပါ။

division ကတော့ အစားကို ပြောတာပါပဲ။

သင်္ချာမှာ floor နဲ့ ceiling ဆိုပြီး ကြမ်းပြင်နဲ့ မျက်နှာကြက် ၊ အနိမ့်နဲ့ အမြင့် ၊ အနည်းနဲ့အများ ဆိုတာမျိုး သုံးလေ့ ရှိကြပါတယ်။

မူလတန်ဖိုးထက် နည်းတဲ့တန်ဖိုးကို floor လို့ ခေါ်ပြီး ပိုများနေရင်တော့ ceiling လို့ ခေါ်ကြပါတယ်။

---

ရိုးရိုး အစားမှာ 16 ရဖို့အတွက် နှစ်ကို ရှစ်ကြိမ်ပေါင်းဖို့ လိုအပ်တာဖြစ်လို့ အဖြေက 8 ဖြစ်ပါမယ်။

17 ရဖို့အတွက်ဆိုရင်တော့ နှစ်ကို ရှစ်ကြိမ်နဲ့ တစ်ဝက်ပေါင်းဖို့ လိုအပ်တာဖြစ်လို့ အဖြေက 8.5 ဖြစ်ပါမယ်။

ကိန်းပြည့်တန်ဖိုးအဖြစ်ပဲ လိုချင်ခဲ့ရင် decimal အစိတ်အပိုင်းကို ဖြတ်ချပြီး နည်းတဲ့တန်ဖိုး 8 ကို ယူလိုက်နိုင်သလို့ round လုပ်ပြီး ပိုနီးစပ်တဲ့ 9 ကို ယူလို့လည်း ရပါတယ်။

---

floor division ကတော့ floor တန်ဖိုးကို ယူတာဖြစ်လို့ 8 ကို ယူပါတယ်။

စားတဲ့အခါ ပိုနည်းတာကို ယူလိုက်တာပေါ့။

မြန်မာလို့ စားလဒ်လို့ ခေါ်ပါတယ်။

သင်္ကေတက double slash ` // ` ပါ။

17 ကို နှစ်နဲ့စားပြီး စားလဒ်ပဲ ယူချင်ရင် Python မှာ `17 // 2` ဆိုပြီး ရေးနိုင်ပါတယ်။

---

##### 7. Modulus

သူက‌လည်း အစားပါပဲ။

ဒါပေမယ့် အကြွင်းကို ယူပါတယ်။

အကြွင်းဆိုတာက စားတဲ့အခါ အကြိမ်အရေအတွက် အတိအကျနဲ့ အပြတ်မစားနိုင်ပဲ ကြွင်းကျန်နေသော တန်ဖိုးလို့ အဓိပ္ပါယ်ရပါတယ်။

အကြွင်းရှာဖို့ အတွက် percent symbol ( % )ကို သုံးပါတယ်။

17 ကို နှစ်နဲ့စားပြီး အကြွင်းပဲယူချင်ရင် Python မှာ 17 % 2 ဆိုပြီး ရေးနိုင်ပါတယ်။

---

အစားသုံးခုကို အနှစ်ချုပ်ရရင်

17 ကို နှစ်နဲ့စားရင် စားလဒ်က 8 ဖြစ်ပြီး အကြွင်းက 1 ဖြစ်ပါတယ်။

စားလဒ်ရှာတဲ့(floor division) က စားလဒ်တန်ဖိုးဖြစ်တဲ့ ရှစ်ကို ယူမှာဖြစ်ပြီး

အကြွင်းရှာတဲ့(modulus) ကတော့ တစ်ကို ယူမှာဖြစ်ပါတယ်။

ရိုးရိုးအစား(division) ကတော့ `8.5` ဆိုပြီး အပြတ်စားလိုက်မှာ ဖြစ်ပါတယ်။

---

##### 8. Addition

ရှင်းပြခဲ့ပြီးသား ဖြစ်ပါတယ်။

---

##### 9. Subtraction

ရှင်းပြခဲ့ပြီးသား ဖြစ်ပါတယ်။

---

အနှစ်ချုပ်ရရင်တော့ ကျောင်းမှာ သင်ခဲ့တာတွေပဲဖြစ်လို့ ထူးထူးခြားခြား မရှိပါဘူး။

သင်္ကေတတွေနဲ့ အခေါ်အဝေါ်လေးတွေတော့ အလွတ်ရ‌အောင် မှတ်ထားပေးပါ။

---

မှတ်ရလွယ်အောာင် မှတ်စုထုတ်ပေးထားပါတယ်။

```
1. Exponentiation ( ** ) ( double asterisk )

2. Unary minus ( -1 ) ( negative ) ( negative 1 လို့ ဖတ်ရမှာ ဖြစ်ပါတယ်။ )

3. Unary plus ( +1 ) ( positive )

4. Multiplication ( * ) ( asterisk )

5. Division ( / ) ( forward slash )

6. Floor Division ( // ) ( double slash )

7. Modulus ( % ) ( percent )

8. Addition ( + ) ( plus )

9. Subtraction ( - ) ( minus ) ( 2 - 1 ကို two minus one လို့ ဖတ်ရမှာဖြစ်ပါတယ်။ )

```

---


##### Precedence of arithmetic operators

အလွတ်ကျက်ခိုင်းခဲ့တဲ့ __e u မြှောက်စား ပေါင်းနှုတ်__ မှာ

__e  / u / မြှောက်စား / ပေါင်းနှုတ်__ ဆိုပြီး space ခြားထားတာတွေကို သီးခြားစီ နားပြီး ရွတ်ရပါမယ်။

ဒါဆိုရင် ဦးစားပေးအဆင့်လေးခုကို မှတ်မိပါပြီ။

---

တစ်ခုခုကို အလွတ်ရထားရင် ကျန်တာတွေလည်း အလိုလိုရလာတာဖြစ်လို့ ကျက်ခိုင်းရင် ကျက်လိုက်ပါ။

ဆင်ခြေပေးတတ်ရင် စာမတတ်ပါဘူး။

စာတွေဟာ ဆက်စပ်နေကြတာဖြစ်လို့ ရှေ့မှာသင်ခဲ့သမျှက နောက်သင်ခန်းစာတွေအတွက် လောင်စာတွေ ဖြစ်ပါတယ်။

အဆင့်အလိုက် ထောက်ပံ့ရင်း ဒုံးကျည်လွှတ်သလိုမျိုး သင်ရင်းနဲ့ မြန်လာရတာမျိုးဖြစ်ပါတယ်။

သင်ရင်းနဲ့ လွယ်လာရတာမျိုး ပျော်လာရတာမျိုးပေါ့။

ဒါကြောင့်သာ စာတော်တဲ့ကျောင်းသားတွေဟာ မပျင်းမရိနဲ့ စာလုပ်နိုင်ကြတာဖြစ်ပါတယ်။

ဒီလိုနဲ့ပဲ တော်တဲ့သူက ပိုတော်သွားကြပါတယ်။

---

ဘယ်သူမှတော့ ဘာခံစားချက်မှမရပဲ တစ်နေကုန် စာထိုင်မလုပ်ပါဘူး။

ကျွန်တော်ဆိုရင်လည်း စာရေးရင် စိတ်ဖိအားတွေလျော့ပြီး အနာသက်သာတယ်ခံစားရ‌လို့ ရေးနေတာပါ။

စာအုပ်ဝယ်ရင် ပိုက်ဆံရတာကြောင့်လည်း ပါတာပေါ့။

ပိုက်ဆံကို စက္ကူလို့ပဲ သဘောထားပေမယ့် ပိုက်ဆံရမှသာ အိမ်လခနဲ့ ဆေးရုံတက်တာတွေ ဆိုင်ကယ်ဝယ်တာတွေ လုပ်လို့ရမှာကိုး။

---

သင်ခန်းစာကို ပြန်သွားပြီး ထပ်ရှင်းရရရင်

1.  ပထမဦးစားပေးက exponent ဖြစ်ပါတယ်။

2. ဒုတိယဦးစားပေးက unary plus နဲ့ unary minus ဖြစ်ပါတယ်။

3. တတိယဦးစားပေးက အမြှောက်နဲ့ အစားသုံးခု ဖြစ်ပါတယ်။

4. စတုတ္ထဦးစားပေးက အပေါင်းနဲ့ အနှုတ်ဖြစ်ပါတယ်။

---

မြင်သာအောင် ဥပမာပေးရရင်

ပထမဦးစားပေးဖြစ်တဲ့ exponent က သမ္မတအဆင့်အတန်းလို့ ဆိုကြပါစို့။

ဒါဆိုရင် ဒုတိယဦးစားပေးဖြစ်တဲ့ unary plus နဲ့ unary minus ကတော့ ဒုသမ္မတနှစ်ယောက်ဖြစ်ပါမယ်။

တတိယဦးစားပေး လေးခုကတော့ ဝန်ကြီးလေးယောက်ပေါ့။

စတုထ္ထဦးစားပေး နှစ်ခုကတော့ ဒုဝန်ကြီးပေါ့။

ဖြေရှင်းကြရတဲ့အခါ သမ္မတနဲ့ ဒုသမ္မတအတူတူလာခဲ့ရင် ဘယ်သူ့ကို အရင်ကြိုရမလဲဆိုတာမျိုး တွေးနိုင်ပါတယ်။

---

Example.1    --->   `2 * 2 ** 3`

exponentiation operator နဲ့ multiplication operator ဆိုပြီး operator နှစ်ခု ပါဝင်နေပါတယ်။

ထုံးစံအတိုင်း ရွေးစရာနှစ်ခု ဖြစ်လာပါတယ်။

ပထမနည်းကတော့ exponentiationကို ဦးစားပေးပြီး အရင်ဖြေရှင်းတာ ဖြစ်ပါတယ်။

```
2 * 2 ** 3

>>   2 * 8

>>   256
```

---

ဒုတိယနည်းကတော့ multiplication ကို ဦးစားပေးပြီး အရင်ဖြေရှင်းတာ ဖြစ်ပါတယ်။

```

2 * 2 ** 3

>>   4 ** 3

>>   64

```

exponentiation ကို အရင်ရှင်းခဲ့ရင်  256 ရမှာဖြစ်ပြီး multiplication ကို အရင်ရှင်းခဲ့ရင်တော့ 64 ရမှာဖြစ်ပါတယ်။

---

ဒုသမ္မတနှစ်ယောက်လိုမျိုး ရာထူးတူတာလာခဲ့ရင် ဘယ်သူ့ကို ဦးစားပေးရမလဲဆိုတာမျိုးကြတော့ associativity ဆိုပြီး ထပ်ရေးပေးပါ့မယ်။

associativity ဆိုတာကတော့ အဆင့်တူအချင်းချင်းကြားက ဆက်စပ်မှု ဖြစ်ပါတယ်။

---

Exercise.1

Example.1 ကို ဖြေရှင်းရတဲ့အခါ

Python က ဘယ် operator ကို ဦးစားပေးပြီး အရင်ဖြေရှင်းမယ်ထင်ပါသလဲ။

ဘယ်နည်းကို ရွေးချယ်မယ်လို့ ထင်ပါသလဲ။

---

Exercise.2

အဆင့်လေးဆင့်‌ထဲက တစ်ခုစီပါအောင် ကိုယ့်ဘာသာ မေးခွန်းထုတ်ပြီး အဆင့်အလိုက် တွက်ကြည့်ပါ။

တွက်ထားတာကို comment မှာ ရေးခဲ့ပေးပါ။

---

Exercises တွေ မဖြေပဲ နောက်စာတွေကို နားလည်မှာ မဟုတ်ပါဘူး။

ဖြေလိုက်မှသာ တွေးမိသွားပြီး ကြားဖူးနားဝအဆင့်ကနေ ကိုယ်ပိုင်ဉာဏ်ဖြစ်သွားမှာ ဖြစ်ပါတယ်။

---

operator က ငါးဆယ်လောက်ရှိတာ ဖြစ်ပါတယ်။

တစ်ခုချင်းစီကို အဆင့်အလိုက် လွယ်အောင် ရေးထားတာဖြစ်လို့ လွယ်ချင်ရင် တစ်ခုချင်း အပိုင်မှတ်သွားပါ။

---


## 23. Associativity

အဆင့်တူအချင်းချင်းကြားက ပတ်သတ်မှုကို ပြောတာဖြစ်ပါတယ်။

တစ်ခုသတိထားရမှာက ဒီစာတွေဟာ သင်္ချာသင်နေတာမဟုတ်ပဲ Python သင်နေတာသာ ဖြစ်ပါတယ်။

Operator တွေနဲ့ ပတ်သတ်ပြီး Python က ဘယ်လို ဘာသာပြန်နေလဲဆိုတာကို ရှင်းရှင်းလင်းလင်း နားလည်စေဖို့ ရည်ရွယ်ရေးသားထားခြင်းသာ ဖြစ်ပါတယ်။

သင်ခန်းစာကို ပြန်ကောက်ရရင် အဆင့်တူအချင်းချင်းကြားက ပတ်သတ်မှုကို မှတ်ဖို့အတွက် တူညီတဲ့ အဆင့်တွေကို အရင်သိထားရမှာဖြစ်ပါတယ်။

မှတ်စရာ တစ်ခုတည်းရှိပြီး တော်တော်လေးလွယ်ပေမယ့်လည်း အများစုက‌တော့ အဆင့်တွေကို ဝေဝါးပြီး အမှတ်မှားတတ်ကြပါတယ်။

---

ရှေ့သင်ခန်းစာမှာ operator ကိုးမျိုးရဲ့ အဆင့်တွေကို ရှင်းပြခဲ့ပါတယ်။

1.  ပထမဦးစားပေးက exponent ဖြစ်ပါတယ်။

2. ဒုတိယဦးစားပေးက unary plus နဲ့ unary minus ဖြစ်ပါတယ်။

3. တတိယဦးစားပေးက အမြှောက်နဲ့ အစားသုံးခု ဖြစ်ပါတယ်။

4. စတုတ္ထဦးစားပေးက အပေါင်းနဲ့ အနှုတ်ဖြစ်ပါတယ်။

စုစုပေါင်း အဆင့်လေးဆင့်ရှိပြီး သမ္မတ ၊ ဒုသမ္မတ ၊ ဝန်ကြီးနဲ့ ဒုဝန်ကြီးဆိုတာမျိုး ဥပမာပေးခဲ့ပါတယ်။

---

exponent ကို ဥပမာပေးပြီး ရှင်းပြရရင် ကုလသမ္မဂမှာ သမ္မတနှစ်ယောက် လာတယ်ဆိုပါစို့။

အမေရိကန်သမ္မတနဲ့ တစ်ခြားနိုင်ငံငယ်တစ်ခုခုက သမ္မတဆိုရင် ဘယ်သူ့ကို ဦးစားပေးမယ် ထင်ပါသလဲ။

စည်းမျဉ်းအရတော့ ဗီတိုအာဏာကိုင်ဆွဲထားတဲ့ အမေရိကန်သမ္မတကို ဦးစားပေးရပါလိမ့်မယ်။

ဆိုလိုတာက သမ္မတအချင်းချင်း ရာထူးတူရင်တောင် ဘယ်သူ့ကိုဦးစားပေးမယ်ဆိုတာမျိုး ရှိနေပါသေးတယ်။

ခင်တဲ့သူ ၊ ချစ်တဲ့သူ ၊ အာဏာရှိတဲ့သူ ၊ တာဝန်ရှိတဲ့သူ စသဖြင့် ဦးစားပေးမှု စည်းမျဉ်းတွေ အများကြီး ရှိကြပါတယ်။

---

Python မှာကတော့ စည်းမျဉ်းတစ်ခုပဲ ရှိပါတယ်။

အဆင့်တူနေရင် __left sided bind / right sided bind__ ဆိုတဲ့ စည်းမျဉ်းတစ်ခုတည်းနဲ့ ဖြေရှင်းပါတယ်။

##### left sided bind

left sided ဆိုတာက ဘယ်ဘက်ကို ပြောတာပါ။

bind ဆိုတာက သင်္ချာမှာ ဖြေရှင်းတာကို ‌ဆိုလိုပါတယ်။

left sided bind ဆိုတော့ ဘယ်ဘက်ကို အရင်ဖြေရှင်းတာ‌လို့ အဓိပ္ပါယ်ရပါတယ်။

################################################

##### right sided bind

right sided bind ကြတော့လည်း ညာဘက်ကို အရင်ဖြေရှင်းတာ‌လို့ အဓိပ္ပါယ်ရပါတယ်။

################################################

##### Example.1    --->  ` 2 ** 2 **  3 `

ထုံးစံအတိုင်း ရွေးစရာနှစ်ခု ရှိလာပါတယ်။

##### choice.1 ( ဘယ်ဘက်ကို အရင်ရှင်း )

```

2 ** 2 ** 3

>> 4 ** 3

>> 64

```

---

##### choice.2 ( ညာဘက်ကို အရင်ရှင်း )

```

2 ** 2 ** 3

>> 2 ** 8

>> 256

```

---

ဘယ်ဘက်ကို အရင်ရှင်းခဲ့ရင် 64 ရမှာဖြစ်ပြီး ညာဘက်ကို အရင်ရှင်းခဲ့ရင် 256 ရမှာဖြစ်ပါတယ်။

---

ပထမဦးစားပေးဖြစ်တဲ့ exponent တွေကို  Python မှာ right sided bind လို့ သတ်မှတ်ထားပါတယ်။

ဒါကြောင့် choice.2 အတိုင်း ဖြေရှင်းပါလိမ့်မယ်။

---

Operator 43 ခုကို အဆင့်အလိုက်စီပြီး ရာထူးပေးလိုက်ရင် အဆင့် 15 ဆင့် ထွက်လာမှာဖြစ်ပြီး အဆင့်တစ်ခုချင်းစီမှာ __left sided bind နဲ့ right sided bind__ ဆိုပြီး သီးခြားစီ ရှိနေကြပါတယ်။

တစ်ချို့အဆင့်တွေက အဆင့်တူနေရင် ဘယ်ကစပြီးဖြေရှင်းမှာဖြစ်ပြီး တစ်ချို့တွေကတော့ ညာဘက်က စကြပါတယ်။

အဆင့်တွေကို အလွတ်ရဖို့လိုအပ်သလို အဆင့်တစ်ခုစီရဲ့ Associativity တွေကိုလည်း သိထားရမှာဖြစ်ပါတယ်။

---

စာတစ်တန်ပေတစ်တန်နဲ့ ရေးနေရလို့သာ ရှုတ်နေပေမယ့် အသုံးများတဲ့ operator တွေထဲမှာတော့ exponent နဲ့ assignment operator တွေကလွဲလို့ ကျန်တာအားလုံးက left sided bind ဆိုတာမျိုး မှတ်ထားနိုင်ပါတယ်။

ခြုံပြီး မှတ်ရမှာဖြစ်လို့ Operator အားလုံးသင်ပြီးမှပဲ ပြန်ပြီး အနှစ်ချုပ်ပေးပါ့မယ်။

---

##### Exercise of precedence & associativity

`1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - 2 ** 3`

အထက်ပါ exercise တွင်  ` +, *, - , %, * , /, *, // ,  -, **  ` ဟူ၍ operator စုစုပေါင်း ဆယ်ခု ပါဝင်ပါသည်။

ထိုဆယ်ခုတွင် မတူညီသော အဆင့် သုံးမျိုး ပါဝင်ပါသည်။

ထိုဆယ်ခု၏ အဆင့်များမှာ

အဆင့်တစ်ဖြစ်သော __exponent တစ်ခု__ ၊

အဆင့်သုံးဖြစ်သော __အမြှောက် သုံးခုနှင့် အစားသုံးခု__ (စုစုပေါင်း ခြောက်ခု) ၊

အဆင့်လေးဖြစ်သော __အပေါင်းတစ်ခုနှင့် အနှုတ် နှစ်ခု__ (စုစုပေါင်း သုံးခု) စသည်တို့ ဖြစ်ကြပါသည်။

__အဆင့်တစ်တစ်ခု ၊ အဆင့်သုံးခြောက်ခုနှင့် အဆင့်လေးသုံးခု__ စုစုပေါင်း operator ဆယ်ခုကို step သုံးခုခွဲ၍ ရှင်းပြပေးပါ့မယ်။

---

##### step.1

ပထမဦးစားပေး အဆင့်တစ်ဖြစ်သော  exponent ကို အရင်ဖြေရှင်းပါမည်။

` 2 ** 3 ` ကို ဖြေရှင်းပြီး ရလာသော အဖြေ `8` ကို အစားထိုးပါမည်။

```

1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - (2 ** 3)

>>   1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - 8

```

---

##### step.2

ဒုတိယဦးစား‌ပေးရမည့် unary plus/ minus များမပါဝင်သဖြင့် တတိယဦးစားပေးဖြစ်သော အ‌မြှောက်သုံးခုနဲ့ အစားသုံးမျိုးကို ဖြေရှင်းပါမည်။

အမြှောက်နှင့် အစားများသည် အဆင့်တူနေကြသဖြင့် အဆင့်တူအချင်းချင်းကြားက ပတ်သတ်မှု ( associativity ) အရ ဖြေရှင်းပါမည်။

တတိယဦးစားပေးဖြစ်သော အမြှောက်အစားများ၏ Associativity မှာ left sided bind ဖြစ်သဖြင့် ဘက်ဘက်စွန်းမှစ၍ တစ်ခုချင်းဖြေရှင်းပါမည်။

`1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - 8 `


##### step.2.1   --->   ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 2 * 3 ကို ဖြေရှင်းသည်။

```

1 + (2 * 3) - 4 % 5 * 6 / 7 * 8  // 9 - 8

>> 1 + 6 - 4 % 5 * 6 / 7 * 8  // 9 - 8

```


##### step.2.2   --->   အဖြေ၏ ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 4 % 5  ကို ဖြေရှင်းသည်။ အကြွင်း 4 ရပါမည်။

```

1 + 6 - (4 % 5) * 6 / 7 * 8  // 9 - 8

>> 1 + 6 - 4 * 6 / 7 * 8  // 9 - 8

```


##### step.2.3   --->   အဖြေ၏ ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 4 * 6 ကို ဖြေရှင်းသည်။  24 ရပါမည်။

```

1 + 6 - (4 * 6) / 7 * 8  // 9 - 8

>  1 + 6 - 24  / 7 * 8  // 9 - 8

```


##### step.2.4   --->   အဖြေ၏ ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 24 / 7 ကို ဖြေရှင်းသည်။

အပြတ်စားသည့်အခါ float တန်ဖိုးကိုသာ ပေးမည်ဖြစ်သဖြင့် __3.4285714285714284__ ရပါမည်။

```

1 + 6 - (24  / 7) * 8  // 9 - 8

>> 1 + 6 -  3.4285714285714284 * 8  // 9 - 8

```


##### step.2.5   --->   အဖြေ၏ ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော  3.4285714285714284 * 8 ကို ဖြေရှင်းသည်။

data အမျိုးအစားမတူသဖြင့် right operand ကို float ပြောင်းပြီး မြှောက်ရာမှ 27.428571428571427 ရပါမည်။

```

1 + 6 -  (3.4285714285714284 * 8)  // 9 - 8

>> 1 + 6 - 27.428571428571427 // 9 - 8

```


##### step.2.6   --->   အဖြေ၏ ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 27.428571428571427 // 9 ကို ဖြေရှင်းသည်။

data အမျိုးအစားမတူသဖြင့် right operand ကို float ပြောင်းပြီး စားရာမှ စားလဒ် 3.0 ရပါမည်။

```

1 + 6 - (27.428571428571427 // 9) - 8

>> 1 + 6 - 3.0 - 8

```

---

##### step.3

ဦးစားပေးမှု အဆင့်လေးဖြစ်သော အပေါင်းတစ်ခုနှင့် အနှုတ် နှစ်ခုကို ဖြေရှင်းပါမည်။

စတုတ္ထဦးစားပေးဖြစ်သော အပေါင်းအနှုတ်များ၏ Associativity မှာ left sided bind ဖြစ်သဖြင့် ဘက်ဘက်စွန်းမှစ၍ တစ်ခုချင်းဖြေရှင်းပါမည်။

`1 + 6 - 3.0 - 8`


##### step.3.1   --->   ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 1 + 6 ကို ဖြေရှင်းသည်။

```

(1 + 6) - 3.0 - 8

>> 7 - 3.0 - 8

```


##### step.3.2   --->   ဘက်ဘက်တွင် ပထမဆုံးတွေ့သော 7 - 3.0 ကို ဖြေရှင်းသည်။

data အမျိုးအစားမတူသဖြင့် left operand ကို float ပြောင်းပြီး နှုတ်ရာမှ 4.0 ရပါမည်။

```

(7 - 3.0) - 8

>> 4.0 - 8

```


##### step 3.3

4.0 - 8 ကို ဖြေရှင်းရာ data အမျိုးအစားမတူသဖြင့် right operand ကို float ပြောင်းပြီး နှုတ်ရာမှ - 4.0 ရပါမည်။

```

(4.0 - 8)

>> - 4.0

```

Python သည် __implicit type casting ၊ precedence နှင့် associativity__ စသည်တို့ကို အသုံးပြု၍ အထက်ပါအတိုင်း ဖြေရှင်းသွားမည်ဖြစ်ပါသည်။

ဒါတွေ မတွက်တတ်လည်း ရေးလို့ရပေမယ့် Python ရဲ့ ဖြေရှင်းပုံကို အသေးစိတ် နားလည်ထားခဲ့ရင်တော့ အရေးအကြောင်းဆိုရင် ချက်ချင်းဖြေရှင်းနိုင်မှာပဲ ဖြစ်ပါတယ်။

---

operator ဆယ်ခုရဲ့ ဖြေရှင်းပုံ အဆင့်ဆင့်ကို စာမပါပဲ ရှင်းပြရရင် ဒီလိုဖြစ်ပါမယ်။

```

1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - 2 ** 3

1. 1 + 2 * 3 - 4 % 5 * 6 / 7 * 8  // 9 - (2 ** 3)

2. 1 + (2 * 3) - 4 % 5 * 6 / 7 * 8  // 9 - 8

3. 1 + 6 - (4 % 5) * 6 / 7 * 8  // 9 - 8

4. 1 + 6 - (4 * 6) / 7 * 8  // 9 - 8

5. 1 + 6 - (24  / 7) * 8  // 9 - 8

6. 1 + 6 -  (3.4285714285714284 * 8)  // 9 - 8

7. 1 + 6 - (27.428571428571427 // 9) - 8

8. (1 + 6) - 3.0 - 8

9. (7 - 3.0) - 8

10. (4.0 - 8)

Anaswer : -4

```

---

ရေးတဲ့အခါ ကိုယ်တိုင်တွက်ဖို့ မလိုအပ်ပေမယ့် Procedural programming ကို လေ့လာနေရတာဖြစ်ပြီး  ကွန်ပြူတာကို အတိအကျ အစီအစဉ်ချပြီး ထိန်းချုပ်ရမှာဖြစ်လို့ Python ဘယ်လို အလုပ်လုပ်နေလဲ / computer ဘယ်လိုအလုပ်လုပ်နေလဲ ဆိုတာကို အတိအကျနီးပါး ခန့်မှန်းနိုင်နေရမှာ ဖြစ်ပါတယ်။

---

__Exercises__ အနေနဲ့ ကိုယ့်ဘာသာ ရေးချင်ရာ ငါးပုဒ်ရေးပြီး အဆင့်အလိုက် စာမပါပဲ ဖြေရှင်းပါ။

အခု exercise ကိုလည်း တစ်ကနေ ကိုးအထိ အစဉ်လိုက်ရေးပြီး operator ဆယ်ခုကို ကြုံသလို ထည့်ထားပြီး ဖြေရှင်းပြထားတာ ဖြစ်ပါတယ်။


---


## 24. Bitwise operators (6)

##### Bit

bit ဆိုတာ ကွန်ပြူတာရဲ့ data ပမာဏကို ဖော်ပြတဲ့ အရာတစ်ခုပါ။

တိုက်ရိုက်အဓိပ္ပါယ်ကတော့ သေးသေးလေးလို့ အဓိပ္ပါယ်ရပါတယ်။

ဘယ်လိုသေးသလဲ ဥပမာပေးရရင် computer မှာ RAM 8 GB ရှိပါတယ်။ 8 GB ဆိုတာက 8 Gigabyte ဖြစ်ပါတယ်။ အလွယ်မှတ်ရင် Giga ဆိုတာကို သန်းတစ်ထောင်လို့ မှတ်ထားနိုင်ပါတယ်။

##### byte

byte ကလည်း ကွန်ပြူတာရဲ့ data ပမာဏတစ်ခုပါပဲ။

byte တစ်ခုမှာ 8 bits ပါဝင်ပါတယ်။

အိမ်တစ်လုံးမှာ အခန်းရှစ်ခုပါသလိုမျိုးပေါ့။

8GB ဆိုတော့ byte ပေါင်း သန်းရှစ်ထောင်လို့ ယူဆနိုင်ပါတယ်။

bit နဲ့ တွက်ရင်တော့ သန်းရှစ်ထောင်ကို 8 နဲ့ ထပ်မြှောက်ရပါလိမ့်မယ်။

ဒါဟာ အလွယ်နည်းနဲ့ ပြောထားတာဖြစ်ပါတယ်။

တကယ့်အတိအကျတွက်ရင် ဒီထက်နည်းနည်းပိုများပါတယ်။

```

8 GB
= 8 × 1024 MB
= 8 × 1024 × 1024 KB
= 8 × 1024 × 1024 × 1024 Bytes
= 8 × 1024 × 1024 × 1024 × 8 bits
= 68,719,476,736 bits

```

8 GB ဖြစ်လာဖို့ bit သန်းပေါင်းများစွာ ပေါင်းစပ်ထားရတာဖြစ်ပြီး

ခုလိုမျိုး အသေးငယ်ဆုံးယူနစ်ဖြစ်လို့ bit လို့ ခေါ်ကြတာဖြစ်ပါတယ်။

---

bit တစ်ခုမှာ ဖြစ်နိုင်ခြေနှစ်ခုကို တစ်လှည့်စီသိမ်းနိုင်ပါတယ်။

အနီးစပ်ဆုံးပြောရရင် မီးခလုတ်လိုမျိုးပါပဲ။

မီးခလုတ်မှာ အပိတ်/ အဖွင့် နှစ်ခုထဲက တစ်ခုထားနိုင်သလိုမျိုး ယူဆနိုင်ပါတယ်။ မီးခလုတ်ဖွင့်ရင် လျှပ်စစ်စီးမှာဖြစ်ပြီး မီးသီးက မီးလင်းပါမယ်။ ပိတ်ရင်တော့ လျှပ်စီးပတ်လမ်း ပြတ်တောက်သွားပါမယ်။

လျှပ်စစ်စီးတာကို 1 လို့ ယူဆမယ်ဆိုရင် မီးခလုတ်နှစ်ခုကို ဖွင့်လိုက်ကြောင်း အမှတ်အသားလုပ်ဖို့ 11 လို့ ရေးနိုင်သလို လျှပ်စစ်မစီးတာကို 0 လို့ ယူဆမယ်ဆိုရင်လည်း မီးခလုတ်နှစ်ခုကို ပိတ်လိုက်ကြောင်း အမှတ်အသားလုပ်ဖို့အတွက် 00 လို့ ရေးနိုင်ပါတယ်။

ဒီလိုမျိုး အမှတ်အသားနှစ်ခုတည်းကို အသုံးပြုပြီး ‌ရေတွက်တာ / ဖော်ပြတာကို binary numbering system လို့ ခေါ်ပြီး ပါဝင်တဲ့ နံပါတ်နှစ်ခုကိုတော့ __binary digit__ လို့ ခေါ်ပါတယ်။

---

binary ရဲ့ အစနှစ်လုံးနဲ့ digit နဲ့ နောက်ဆုံးတစ်ခုကို ပေါင်းပြီး bit လို့ ခေါ်ကြပါတယ်။

ဒါကြောင့် __bit__ ဟာ __binary digit__ ရဲ့ အတိုကောက်ဖြစ်ပါတယ်။

---

ကွန်ပြူတာမှာ binary digit တွေကိုသုံးပြီး ပုံတွေ ၊ စာ‌တွေ ၊ video တွေ စတာတွေ အားလုံးကို မှတ်သားထားကြပါတယ်။

---

Python မှာ ကိန်းဂဏန်းတွေနဲ့ ပတ်သတ်တဲ့ လုပ်ဆောင်ချက်တွေအတွက် arithmetic operator တွေကို ဖန်တီးထားသလို Bit နဲ့ပတ်သတ်တဲ့ လုပ်ဆောင်ချက်တွေအတွက်လည်း bitwise operator တွေကို ဖန်တီးပေးထားပါတယ်။

---

#### Bitwise Operators

Bit (binary digit) နဲ့ သက်‌ဆိုင်သော operator များလို့ အဓိပ္ပါယ်ရပါတယ်။

binary digit တွေနဲ့ ပတ်သတ်ပြီး operation တွေပြုလုပ်ဖို့ သုံးပါတယ်။

စုစုပေါင်း ခြောက်ခု ရှိပါတယ်။

##### 1. Left shift ( << )

left က ဘယ်ဘက်ဖြစ်ပြီး shift ကတော့ ရွေ့တာကို ဆိုလိုပါတယ်။

binary digit တွေကို ဘယ်ဘက်ကို ရွေ့စေချင်ရင် သုံးပါတယ်။

ဘယ်ဘက်ကို ရွှေ့တဲ့အခါ ညာဘက်စွန်းကို zero ဖြည့်ပေးပါတယ်။

လက်တွေ့ပြရရင်

00001011 ကို ဘယ်ဘက်ကို တစ်နေရာ ရွှေ့ခဲ့ရင် 00010110 ဖြစ်သွားပါမယ်။

```

>>   00001011
>> 000010110

```

အပေါ်ကလိုမျိုး ရှစ်ခုလုံးကို ဘယ်ဘက်ကို ရွှေ့လိုက်ပြီး ညာဘက်မှာ zero ဝင်လာပါမယ်။

ဒီနေမှာ ထိုင်ခုံမလောက်တဲ့ ပြသနာတစ်ခုတော့ ရှိပါတယ်။

လူရှစ်ယောက်က ထိုင်ခုံရှစ်ခုံမှာ ထိုင်နေရင်းကနေ ညာဘက်အစွန်က ထိုင်ခုံကို အလွတ်ထားဖို့အတွက် ဘယ်ဘက်ကို တစ်နေရာစီရွှေ့ခဲ့ရင် ဘယ်ဘက်စွန်းလူအတွက် ထိုင်ခုံမရှိတော့ပါဘူး။

left shift လုပ်တဲ့အခါမှာလည်း computer မှာ binary digit ရှစ်ခုပဲ လက်ခံဖို့ရည်ရွယ်ထားခဲ့ရင် ရှစ်ခုပဲ မှတ်သားပေးမှာဖြစ်လို့ နေရာမရှိတဲ့ ဘယ်အစွန်တစ်ခုက အထုတ်ခံရပါလိမ့်မယ်။

```

>>   00001011
>>   00010110

```

---

အထုတ်ခံရတာကို ပိုမြင်အောင် ဥပမာ ထပ်ပေးပါ့မယ်။

1011 ကို ဘယ်ဘက်ရွှေ့တဲ့အခါ အောက်ကလိုရပါတယ်။

```

>>   1011
>> 10110

```

computer က binary digit လေးခုပဲ ယူခဲ့မယ်ဆိုရင် ဘယ်အစွန်က နေရာမရှိသူ ဖယ်ထုတ်ခံရပါမယ်။

```

>>   1011
>>   0110

```

---

##### 2. Right shift ( >> )

right က ညာဘက်ဖြစ်ပြီး shift ကတော့ ရွှေ့တာကို ဆိုလိုပါတယ်။

binary digit တွေကို ညာဘက်ကို ရွှေ့စေချင်ရင် သုံးပါတယ်။

ညာဘက်ကို ရွှေ့တဲ့အခါ ဘယ်ဘက်စွန်းကို zero ဖြည့်ပေးပါတယ်။

သူ့မှာလည်း ထိုင်ခုံမလောက်တဲ့ ပြသနာ ရှိပါတယ်။

ညာဘက်ကို ထိုင်ခုံ‌တစ်နေရာစာ ရွှေ့ကြရတဲ့အခါ ညာအစွန်လူက ထိုင်ခုံပျောက်ပါလိမ့်မယ်။

ဒါတွေက ကိုယ်တိုင်တွေးမှ နားလည်တာဖြစ်လို့ ထိုင်ခုံတွေကို မြင်ယောင်ပြီး left shift က ဥပမာအတိုင်း ကျွန်တော့်ကို ပြန်ရှင်းပြပါ။

ရှင်းပြတဲ့ သင်ခန်းစာကို comment မှာ ရေးခဲ့ပေးပါ။

---

##### 3. Bitwise AND  ( & )

__I love freedom and wisdom.__ ထဲက and နဲ့ အတူတူပါပဲ။

နှစ်ခုလုံးကို တန်ဖိုးထားတယ်ဆိုတာမျိုးပေါ့။

တစ်ခုတစ်လေ မဟုတ်ပဲ အားလုံးကို ရည်ညွှန်းတာမျိုးပါ။

binary digit တွေကို ပေါင်းတဲ့အခါ တန်ဖိုးနှစ်ခုလုံး one ဖြစ်မှသာ one လို့ ယူပါတယ်။

```

>>   0010
            &
>>   0011
   ------------------------
>>   0010

```

ညာဘက်စွန်းက 0 နဲ့ 1 ကို ပေါင်းတဲ့အခါ အားလုံး one မဟုတ်လို့ zero ကို ယူပါတယ်။

ဒုတိယမြောက်နှစ်ကို ပေါင်းတဲ့အခါ အားလုံး one ဖြစ်ကြလို့ 1 လို့ ယူပါတယ်။

ဘယ်အစွန်နှစ်ခုကတော့ တစ်ခုမှ one မဖြစ်လို့ zero ပဲ ယူပါတယ်။

ဒါကြောင့် 0010 နဲ့  0011 ကို AND operation လုပ်တဲ့အခါ 0010 ရပါမယ်။

---

ဘာကြောင့် ဒီလိုရလဲဆိုတော့ လျှပ်စီးပတ်လမ်းထဲမှာ input နှစ်ခုလုံးကနေ လျှပ်စစ်ဝင်လာမှသာ output အဖြစ် လျှပ်စစ်ပြန်ထွက်မယ်ဆိုတာမျိုး ဖန်တီးထားတာကြောင့်ပါ။

တံခါးကို သော့နှစ်ခုတွဲပြီး ခတ်ထားသလိုပေါ့။

သော့အားလုံးပွင့်မှသာ တံခါးဖွင့်လို့ ရပါမယ်။

ဒါကြောင့် အလွယ်မှတ်ချင်ရင် all လို့ မှတ်ထားနိုင်ပါတယ်။

---

##### 4. Bitwise OR  ( | )

__Please give me an apple or a banana.__ ထဲက or နဲ့ အတူတူပါပဲ။

တစ်ခုတစ်လေ ပေးလိုက်ရုံနဲ့တင် ကျေနပ်သွားမှာဖြစ်သလို နှစ်ခုလုံးပေးလိုက်လို့လည်း စိတ်မဆိုးပါဘူး။

binary digit တွေကို ပေါင်းတဲ့အခါ တန်ဖိုးတစ်ခုတစ်လေ one ဖြစ်ရုံနဲ့တင် one လို့ ယူပါတယ်။

```

>>   0010
            |
>>   0011
   ------------------------
>>   0011

```

ညာဘက်စွန်းက 0 နဲ့ 1 ကို ပေါင်းတဲ့အခါ one တစ်ခုပါလို့ one လို့ ယူပါတယ်။

ဒုတိယမြောက်နှစ်ခုမှာ အားလုံး one ဖြစ်ကြချိန်မှာလဲ 1 လို့ပဲ ယူပါတယ်။

ဘယ်အစွန်နှစ်ခုကတော့ တစ်ခုမှ one မဖြစ်လို့ zero ပဲ ယူပါတယ်။

ဒါကြောင့် 0010 နဲ့  0011 ကို OR operation လုပ်တဲ့အခါ 0011 ရပါမယ်။

ဘာကြောင့် ဒီလိုရလဲဆိုတော့ လျှပ်စီးပတ်လမ်းထဲမှာ input တစ်ခုခုကနေ လျှပ်စစ်ဝင်လာရုံနဲ့ output အဖြစ် လျှပ်စစ်ပြန်ထွက်မယ်ဆိုတာမျိုး ဖန်တီးထားတာကြောင့်ပါ။

သော့ခလောက်တစ်ခုတည်းကို သော့နှစ်ချောင်းပွားထားသလိုပါပဲ။

ဘယ်သော့နဲ့ဖွင့်ဖွင့် ပွင့်ပါတယ်။

ဒါကြောင့် အလွယ်မှတ်ချင်ရင် any လို့ မှတ်ထားနိုင်ပါတယ်။

---

##### 5. Bitwise XOR ( ^ )

XOR ဆိုတာက Exclusive OR ဖြစ်ပါတယ်။

Exclusive ဆိုတာက အထူးသီးသန့်ပါ။

Exclusive OR ဆိုတော့ OR သီးသန့်ပေါ့။

OR ကို  တစ်ခုတစ်လေလို့ မှတ်ခဲ့မယ်ဆိုရင် Exclusive OR ဆိုတာက တစ်ခုတစ်လေကိုပဲ လက်ခံမယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

---

မုန့်တောင်းစားတဲ့ ဥပမာကို ပြန်သွားရရင်

__Please give me an apple or a banana.__  ဆိုပြီး

သစ်သီးတောင်းတဲ့အခါ တစ်လုံးပဲယူမယ်လို့ ပြောတာမျိုးပါ။

ရွဲ့ပြီး အကုန်ပေးရင်တော့ မယူနိုင်ဘူးဆိုတာမျိုးပေါ့။

ရွဲ့ပြီး မောင်ပဲအကုန်စားလိုက်တော့ဆိုရင် ပျာပျာသလဲငြင်းရသလိုမျိုးပါပဲ။

binary digit တွေကို တစ်ခုချင်းစီပေါင်းတဲ့အခါ တန်ဖိုးတစ်ခုတစ်လေ one ဖြစ်မှသာ one လို့ ယူပါတယ်။

အားလုံး one ဖြစ်ရင် ငြင်းပါတယ်။

```

>>   0010
            ^
>>   0011
   ------------------------
>>   0001

```

ညာဘက်စွန်းက 0 နဲ့ 1 ကို ပေါင်းတဲ့အခါ one တစ်ခုပဲပါလို့ one လို့ ယူပါတယ်။

ဒုတိယမြောက်နှစ်ခုမှာ အားလုံး one ဖြစ်ကြချိန်မှာ‌တော့ ငြင်းပါတယ်။

ဘယ်အစွန်နှစ်ခုကတော့ တစ်ခုမှ one မဖြစ်လို့ zero ပဲ ယူပါတယ်။

ဒါကြောင့် 0010 နဲ့  0011 ကို XOR operation လုပ်တဲ့အခါ 0001 ရပါမယ်။

ဘာကြောင့် ဒီလိုရလဲဆိုတော့ လျှပ်စီးပတ်လမ်းထဲမှာ input တစ်ခုတည်းကပဲ လျှပ်စစ်ဝင်လာမှသာ output အဖြစ် လျှပ်စစ်ပြန်ထွက်မယ်ဆိုတာမျိုး ဖန်တီးထားတာကြောင့်ပါ။

ချိန်ခွင်လိုမျိုးပေါ့။

တစ်ဖက်ဖက်က အလေးသာမှသာ စောင်းသွားပါလိမ့်မယ်။

ဒါကြောင့် အလွယ်မှတ်ချင်ရင် " or သီးသန့် " လို့ မှတ်ထားနိုင်ပါတယ်။

---

##### 6. Bitwise NOT ( ~ )

not ဆိုတာက အငြင်းပြစကားပါ။

binary digit ကို ဆန့်ကျင်ဘက်ပြောင်းဖို့ ‌သုံးပါတယ်။

__zero ကို one အဖြစ် ၊ one ကို zero အဖြစ်__ ပြောင်းပေးပါတယ်။

__0011__ ကို ဆန့်ကျင်ဘက်ပြောင်းရင် __1100__ ရပါမယ်။

နှိပ်တဲ့ ဘောပင်လိုမျိုးပါပဲ။

နှိပ်လိုက်တဲ့အခါ ပိတ်ထားရင် ပွင့်မှာဖြစ်ပြီး ဖွင့်ထားရင်တော့ ပိတ်သွားမှာဖြစ်ပါတယ်။

ခလုတ်နှိပ်တိုင်းမှာ အပိတ်နဲ့ အဖွင့်က တစ်လှည့်စီ ဖြစ်ပါမယ်။

normally open လိုမျိုး ဘာမှ မသက်ရောက်ရင် အလိုလိုပွင့်ပြီး လျှပ်စစ်ပေးခဲ့ရင် ပိတ်မယ်ဆိုတာမျိုးလည်း ဖြစ်ပါလိမ့်မယ်။

---

အနှစ်ချုပ်ရရင် ခြောက်ခုလုံးရဲ့ အမည် ၊ သင်္ကေတတွေနဲ့ အလုပ်လုပ်ပုံတွေကို မှတ်ထားပေးပါ။

ဒါမှသာ Python နဲ့ ရှင်းပြတဲ့အခါ နားလည်ပါလိမ့်မယ်။

---

တကယ်တော့

right shift  တစ်နေရာစာ ရွှေ့တာက နှစ်နဲ့ စားလိုက်တယ်ဆိုတာမျိုး ၊

low level programming မှာ ON, OFF, Toggle လုပ်တာမျိုး

bitwise operators တွေကို ပေါင်းစပ်ပြီး ကစားသွားတာမျိုး ၊

system programming မှာ file permission ပေးတာမျိုး ၊

signed two’s complement လိုမျိုး  တစ်ခြားဗဟုသုတတွေကိုလည်း ရှင်းပြရဦးမှာဖြစ်ပေမယ့် လောလောဆယ်တော့ ဒီအတိုင်းပဲ ရိုးရိုးလေးသာ မှတ်ထားပေးပါ။

Project ရေးတဲ့အဆင့်ကို မရောက်မှာစိုးလို့ Operators အကြောင်းပဲ သီးသန့်ရေးမယ့် စာအုပ်မှပဲ အပြည့်အစုံ ထည့်ရေးပေးပါ့မယ်။

---

အခုလက်ရှိမှာ arithmetic operators ကိုးမျိုးနဲ့ bitwise operators ခြောက်မျိုးကို သင်ခဲ့ပြီးပါပြီ။

```

e
u
မြှောက် စား
ပေါင်း နှုတ်
shift
and
or နှစ်ခု

```

ဒါကို မှတ်ထားခဲ့ရင် 15 ခုလုံးကို အလွတ်ရပါပြီ။

operator precedence  နဲ့ပတ်သတ်ပြီး သင်ပြီးသလောက်ကို အနှစ်ချုပ်ရရင် အတိုကောက်မှာ နားပြီး ရွတ်ရမှာတွေက အဆင့်တွေပါပဲ။

ခုလိုမျိုး ရှစ်ဆင့်ရှိပါတယ်။

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any


သတိထားရမှာက __bitwise NOT__ က precedence မှာ အဆင့်နှစ်ဖြစ်သလို unary operator လည်းဖြစ်လို့ အတိုကောက်ထဲက u ဟာ __unary operator သုံးခု__ ကို ဆိုလိုတယ်လို့ သိထားရပါမယ်။

or နှစ်ခုဆိုရင်လည်း __exclusive OR နဲ့ OR__ လို့ သိရပါမယ်။

သူတို့နှစ်ခုကတော့ အဆင့်မတူကြပါဘူး။

XOR က အဆင့်ပိုမြင့်ပါတယ်။

---

အခုဆက်ပြီးသင်ရမှာကတော့ ကိုးဆင့်မြောက်ဖြစ်တဲ့ Comparison Operators တွေပဲ ဖြစ်ကြပါတယ်။

သူကလည်း bitwise operators တွေလိုပဲ ‌အရေအတွက် ခြောက်ခုရှိပါတယ်။

---


## 25. Comparison Operators (==, !=, >, <, >=, <=) (value)

comparison ဆိုတာက နှိုင်းယှဉ်တာကို ပြောတာပါ။

တန်ဖိုးတွေကို နှိုင်းယှဉ်ဖို့ သုံးပါတယ်။

နှိုင်းယှဉ်တဲ့အခါ မှန်ရင် True ကို ထုတ်ပေးပြီး မမှန်ရင်တော့ False ကို ထုတ်ပေးပါတယ်။

---

တန်ဖိုး တူ / မတူ နှိုင်းယှဉ်ချင်ရင် __== နဲ့ !=__ ကို သုံးနိုင်ပါတယ်။

__equal နဲ့ not equal__ လို့ မှတ်ထားနိုင်ပါတယ်။


`10 == 100`

10 နဲ့ 100 တူတယ်လို့ ရေးခဲ့ရင် မှားလို့ `False` ဖြစ်ပါမယ်။

ဖတ်တဲ့အခါ __10 is equal to 100.__ လို့ ဖတ်နိုင်ပါတယ်။


`10 != 100`

10 နဲ့ 100 မတူဘူးလို့ ရေးခဲ့ရင် မှန်လို့ `True` ဖြစ်ပါမယ်။

ဖတ်တဲ့အခါ __10 is not equal to 100.__ လို့ ဖတ်နိုင်ပါတယ်။

---

တန်ဖိုးတွေကို အကြီး / အငယ် နှိုင်းယှဉ်ချင်ရင် __greater than နဲ့ less than__ ကို သုံးနိုင်ပါတယ်။

`10 > 100 `

__10 is great than100.__ လို့ ရေးခဲ့ရင် မှားလို့ `False` ဖြစ်ပါမယ်။


`10 < 100`

__10 is less than100.__ လို့ ရေးခဲ့ရင် မှန်လို့ `True` ဖြစ်ပါမယ်။

---

နောက်နှစ်ခုကတော့ equal နဲ့ အကြီး/ အငယ်ကို ပေါင်းထားပါတယ်။

##### Greater than or equal ( >= )

`10 >= 100 `

__10 is great than or equal to 100.__ လို့ ရေးခဲ့ရင် 10 ဟာ 100 ထက် မကြီးသလို တန်ဖိုးလည်း မတူညီကြသဖြင့် နှစ်ခုလုံးမှားလို့ `False` ဖြစ်ပါမယ်။


##### Less than or equal ( <= )

`10 <= 100 ` 

__10 is less than or equal to 100.__ လို့ ရေးခဲ့ရင်

10 နဲ့ 100 ဟာ တန်ဖိုးတွေ မတူညီကြပေမယ့် 10 က ပိုငယ်တယ်ဆိုတာကတော့ မှန်နေတာဖြစ်လို့ `True`  ဖြစ်ပါမယ်။


equal နဲ့ အကြီး/ အငယ်ကို ပေါင်းထားတာက တစ်ခုမှန်ရင် လက်ခံတာမျိုးပါ။

---

precedence အနေနဲ့တော့ comparison operators ခြောက်ခုလုံးက အဆင့်အတူတူပါပဲ။

ကိုးဆင့်မြောက်မှာ ရှိကြပါတယ်။

---

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (Unary positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=) (value)

```

```

e
u
မြှောက် စား
ပေါင်း နှုတ်
shift
and
or နှစ်ခု
C

```

C ဆိုတာက comparison operators တွေကို ပြောတာ ဖြစ်ပါတယ်။

မှတ်စုကို နားလည်ခဲ့မယ်ဆိုရင် precedence ကိုးဆင့်နဲ့ operator 21 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

---


## 26. Identity Operators (is, is not) (memory address)

identity document လို့ ခေါ်တဲ့ ID နံပါတ်တွေ တူ / မတူ နှိုင်းယှဉ်ဖို့ သုံးပါတယ်။

computer မှာတော့ memory address တွေကို id လိုမျိုး ယူဆကြပါတယ်။

##### is

အတူတူဖြစ်ပြီး တစ်ခုတည်းလို့ အဓိပ္ပါယ်ရပါတယ်။

x is y လို့ ရေးတဲ့အခါ x ထဲမှာ မှတ်သားထားတဲ့ လိပ်စာနဲ့ y ထဲက လိပ်စာတူနေခဲ့ရင် True ကို ထုတ်ပေးပါမယ်။

မတူရင်တော့ False ပေါ့။

မြင်သာအောင်ပြောရရင် သန့်စင်နဲ့ ဟိန်းကိုဆိုပြီး ကျွန်တော် တစ်ယောက်တည်းမှာ အမည်နှစ်ခု ရှိနေတာမျိုးပါ။

__Thant Sin is Hein Ko.__ ဆိုရင် ဒီအမည်နှစ်ခုက  လူတစ်ယောက်တည်းပဲလို့ ပြောလိုက်တာမျိုးပါ။

တကယ်ပဲ တစ်ယောက်တည်းဖြစ်နေခဲ့ရင် True ပေါ့။

---

Python မှာကြတော့ object တစ်ခုတည်းပဲလားဆိုပြီး စစ်ဖို့အတွက် သုံးပါတယ်။

`x is y` ဆိုရင် __x နဲ့ y ဟာ အရာဝတ္ထု တစ်ခုတည်းရဲ့ အမည်တွေ__ လို့ ပြောလိုက်တာမျိုးပါ။

---

is not

x is not y ဆိုရင် x နဲ့ y က အတူတူ မဟုတ်ဘူးလို့ ပြောလိုက်တာပါ။

လိပ်စာမတူခဲ့ရင် တစ်နည်းအားဖြင့် ID မတူခဲ့ရင် True ကို ထုတ်ပေးမှာဖြစ်ပြီး တူနေခဲ့ရင်တော့ False ကို ထုတ်ပေးမှာ ဖြစ်ပါတယ်။

---

တစ်ခုသတိထားရမှာက

comparison operators  ထဲက __equal နဲ့ not equal__ က တန်ဖိုးတွေကို နှိုင်းယှဉ်တာ ဖြစ်ပြီး

identity operator ထဲက __is နဲ့ is not__ ကတော့ __memory address__ တွေကို နှိုင်းယှဉ်ပေးပါတယ်။

အသေးစိတ်ကိုတော့ program ရေးပြီဆိုမှပဲ ထပ်ဖြည့်ပေးပါ့မယ်။

လောလောဆယ်တော့ အခြေခံလောက် သိထားရင် ရပါပြီ။

တစ်ခါတည်း အကုန်ထည့်သင်လိုက်ရင် လည်ထွက်ကုန်ကြလို့ ပထမစာအုပ်မှာ အရိုးရှင်းဆုံးတွေပဲ အရင်ရေးပေးပါ့မယ်။

အခြေခံပိုင်ပြီဆိုမှပဲ အသေးစိတ် ထပ်ဖြည့်ပေးပါ့မယ်။

---

## 27. Membership Operators ( in , not in )

membership ဖြစ်/မဖြစ် စစ်ဖို့ သုံးပါတယ်။

---

သစ်သီးစာရင်းထဲမှာ ပန်းသီးပါလားစစ်ချင်ရင် ဒီလိုရေးနိုင်ပါတယ်။

`"apple" in fruits`

ပန်းသီးပါခဲ့ရင်` True ` ကို ထုတ်ပေးမှာဖြစ်ပြီး ပန်းသီးမပါရရင်တော့ ` False ` ဖြစ်ပါမယ်။

` not in ` ကြတော့ ဆန့်ကျင်ဘက် ဖြစ်ပါမယ်။

---

နောက်တစ်နည်းနဲ့ ထပ်ရှင်းပြပေးပါ့မယ်။

` "apple" in fruits `

သစ်သီးစာရင်းထဲမှာ ပန်းသီးပါတယ်လို့ ရေးလိုက်တာပါ။

မှန်ခဲ့ရင် True ကို ထုတ်ပေးမှာဖြစ်ပြီး မမှန်ရင်တော့ False ဖြစ်ပါမယ်။


`"apple" not in fruits`

သစ်သီးစာရင်းထဲမှာ ပန်းသီးမပါဘူးလို့ ရေးလိုက်တာပါ။

မှန်ခဲ့ရင် True ကို ထုတ်ပေးမှာဖြစ်ပြီး မမှန်ရင်တော့ False ဖြစ်ပါမယ်။

---

```
1. Comparison Operators (Compare values)(6)
   Equal to                     --->   ==
   Not equal to                 --->   !=
   Greater than                 --->   >
   Less than                    --->   <
   Greater than or equal to     --->   >=
   Less than or equal to        --->   <=

2. Identity Operators (Compare memory locations)
   Identical objects            --->   is
   Not identical objects        --->   is not

3. Membership Operators (Test for membership in sequences)
   Present in the sequence      --->   in
   Not present in the sequence  --->   not in

```

အထက်ပါ ဆယ်ခုလုံးဟာ ဦးစားပေးအဆင့် 9 ဖြစ်ကြပါတယ်။

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (Unary positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=) 
    Identity Operators (is , is not)
    Membership Operators  (in , not in)

```

```

e
u
မြှောက် စား
ပေါင်း နှုတ်
shift
and
or နှစ်ခု
C

```

C ဆိုတာက comparison, identity , membership စတဲ့ operators တွေကို ပြောတာ ဖြစ်ပါတယ်။

မှတ်စုကို နားလည်ခဲ့မယ်ဆိုရင် precedence ကိုးဆင့်နဲ့ operator 25 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

---


## 28. Logical Operators

logic value လို့ ခေါ်တဲ့ True , False တန်ဖိုးနှစ်ခုနဲ့ သက်ဆိုင်တဲ့ operators  တွေဆိုပြီး မှတ်ထားနိုင်ပါတယ်။

---

##### 1. Logical NOT (not)

condition တွေကို ဆန့်ကျင်ဘက်အဖြစ် ပြောင်းလဲပေးပါတယ်။

bitwise not နဲ့ အတူတူပါပဲ။

bitwise not က binary digit တန်ဖိုးဖြစ်တဲ့ zero နဲ့ one တွေကို ဆန့်ကျင်ဘက် ပြောင်းပေးပြီး

logical not ကတော့ logical တန်ဖိုးဖြစ်တဲ့ True နဲ့ False ကို ဆန့်ကျင်ဘက် ပြောင်းပေးပါတယ်။

not True ဆိုရင် False ရပါမယ်။

not False ဆိုရင် True ရပါမယ်။

---

##### 2. Logical AND (and)

bitwise and နဲ့ အတူတူပါပဲ။

တံခါးတစ်ခုတည်းကို သော့နှစ်လုံး ခတ်ထားသလိုမျိုးပါပဲ။

True and True ဆိုပြီး နှစ်ခုလုံး True ဖြစ်မှသာ True ရပါမယ်။

---

##### 3. Logical OR  (or)

bitwise or နဲ့ အတူတူပါပဲ။

False or True ဆိုတာမျိုး True တစ်ခုပါရုံနဲ့ True ရပါမယ်။

---

precedence အရ not, and, or က 10, 11, 12 ဖြစ်ကြပါတယ်။

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=)   (value)
    Identity Operators (is , is not)
    Membership Operators  (in , not in)

10. Logical NOT        --->   not
11. Logical AND        --->   and
12. Logical OR         --->   or



e
u
မြှောက် စား
ပေါင်း နှုတ်
shift
and
or နှစ်ခု
C
not
and
or

```

မှတ်စုကို နားလည်ခဲ့မယ်ဆိုရင် precedence 12 ဆင့်နဲ့ operator 28 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

---

## 29. Ternary operator

ternary ဆိုတာ မြန်မာလို သုံးခုလို့ အဓိပ္ပါယ်ရပါတယ်။

__left, middle, right__ ဆိုပြီး operand အစိတ်အပိုင်း သုံးခုပါတဲ့ operator ဖြစ်ပါတယ်။

__middle operand__ ရဲ့ အခြေအနေပေါ်မူတည်ပြီး တန်းဖိုးနှစ်ခုထဲက တစ်ခုကို ရွေးချယ်ပေးပါတယ်။

middle operand က __True__ ဖြစ်ခဲ့ရင် __left operand__ ကို ရွေးမှာ ဖြစ်ပြီး False ဖြစ်ခဲ့ရင်တော့ right operand ကို ရွေးမှာဖြစ်ပါတယ်။

---

နံပါတ်နှစ်ခုထဲက ပိုကြီးတဲ့ နံပါတ်ကို ရွေးချင်ရင် ဒီလိုရေးနိုင်ပါတယ်။

`greater_number = a if a > b else b`

__a ဟာ b ထက်ကြီးရင် a ကို ယူမယ်__ လို့ ရေးလိုက်တာပါ။


အလုပ်လုပ်ပုံကို ရှင်းပြရရင်

ပထမနံပါတ်ဟာ ဒုတိယနံပါတ်ထက် ကြီးခဲ့ရင်

a ဟာ b ထက်ကြီးခဲ့ရင် `a if True else b` ဖြစ်သွားပါမယ်။

middle operand က `True` ဖြစ်လို့ ဘယ်ဘက်က a ကို ယူပါတယ်။

ပိုကြီးတဲ့ တန်ဖိုးရပါမယ်။

---

a ဟာ  b ထက် မကြီးခဲ့ရင် `a if False else b` ဖြစ်သွားပါမယ်။

middle operand က `False` ဖြစ်လို့ ညာဘက်က b ကို ယူပါတယ်။

ပိုကြီးတဲ့ တန်ဖိုးရပါမယ်။

---

ပိုငယ်တဲ့ တန်ဖိုး လိုချင်ရင်တော့

1. a နဲ့ b ကို နေရာလဲလို့ ရပါတယ်။

`less_number = b if a > b else a`

a က ပိုကြီးရင် b ကို ယူမယ်လို့ အဓိပ္ပါယ်ရပါတယ်။


2. middle operand ကို less than အဖြစ် ပြင်လို့ ရပါတယ်။

`less_number = a if a < b else b`

a က ငယ်ရင် a ကို ယူမယ်လို့ အဓိပ္ပါယ်ရပါတယ်။

ရေးချင်သလို ရေးလိုက်လိုရပေမယ့် ပထမနည်းက အဓိပ္ပါယ်မရှိလို့ မှတ်ရလွယ်တဲ့ ဒုတိယနည်းကိုပဲ သုံးကြပါတယ်။

---

အခြေအနေပေါ်မူတည်ပြီး အလုပ်လုပ်တာဖြစ်လို့ conditional operator လို့လည်း ခေါ်ကြပါတယ်။

if နဲ့ else ပါလို့ if else operator လို့လည်း ခေါ်ကြပါတယ်။

precedence သတ်မှတ်ချက်မှာ အဆင့် 13 ဖြစ်ပါတယ်။

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=)   (value)
    Identity Operators (is , is not)
    Membership Operators  (in , not in)

10.Logical NOT        --->   not
11.Logical AND        --->   and
12.Logical OR         --->   or
13. Ternary operator    --->  operand_1 if operand_3 else operand_2


e
u
မြှောက် စား
ပေါင်း နှုတ်
shift
and
or နှစ်ခု
C
not
and
or
T

```

T က ternary operator ဖြစ်ပါတယ်။

အတိုကောက်ကို နားလည်ခဲ့မယ်ဆိုရင် precedence 13 ဆင့်နဲ့ operator 29 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

---


## 30. Assignment Operators ( = )

assignment ဆိုတာက တစ်ခုခုပေးတာကို ပြောတာပါ။

တန်ဖိုးသတ်မှတ်ပေးတဲ့ operators တွေလို့ ယူဆနိုင်ပါတယ်။

assignment operators က စုစုပေါင်း ဆယ့်သုံးခုရှိပါတယ်။

---

##### 1. Simple assignment ( = )

`x = 5` ဆိုရင် __x is assigned 5__ လို့ ဖတ်နိုင်ပါတယ်။

x ရဲ့ တန်ဖိုးက 5 ဖြစ်တယ်ဆိုတာမျိုးပါ။

ဒါမှမဟုတ်လည်း x ဟာ 5 ကို ကိုယ်စားပြုတယ်ဆိုတာမျိုးပေါ့။

---

##### 2. Add and assign ( += )

`x += 1`

x ရဲ့ တန်ဖိုးအဟောင်းကို တစ်ပေါင်းပြီး ရလာတဲ့တန်ဖိုးအသစ်ကို x ကိုပဲ ပြန်ပေးမယ်ဆိုတာမျိုးပါ။

additional operator နဲ့ assignment operator ဒီနှစ်ခုကို ပေါင်းပြီး ရေးလိုက်တာပါ။

ဖတ်တဲ့အခါ နှစ်မျိုး ဖတ်နိုင်ပါတယ်။

1. __Add 1 to x and assign the result back to x.__

2. __x add and assign 1.__

---

##### 3. Subtract and assign ( -= )

တန်ဖိုးအဟောင်းကို နှုတ်ပြီး ရလာတဲ့ ရလဒ်ကို assign ပြန်လုပ်တာပါ။

---

ကျန်တာတွေလည်း အတူတူပဲဖြစ်လို့ မရေးတော့ပါဘူး။

စုစုပေါင်း ဆယ့်သုံးခုရှိပါတယ်။

1. Simple assignment ( = )
2. Add and assign ( += )
3. Subtract and assign ( -= )
4. Multiply and assign ( \*= )
5. Divide and assign ( /= )
6. Floor divide and assign ( //= )
7. Modulus and assign ( %= )
8. Exponent and assign ( \*\*= )
9. Bitwise AND and assign ( &= )
10. Bitwise OR and assign ( |= )
11. Bitwise XOR and assign ( ^= )
12. Right shift and assign ( >>= )
13. Left shift and assign ( <<= )

အနှစ်ချုပ်ရရင်

arithmetic operators ကိုးခုနဲ့ bitwise operators ခြောက်ခု စုစုပေါင်း ဆယ့်ငါးခုရှိပါတယ်။

unary minus, unary plus, bitwise not အစရှိတဲ့ unary operator သုံးခုကို ဖယ်လိုက်ရင် binary operator 12 ခု ကျန်ပါတယ်။

ဒီ 12 ခုကို assignment operator နဲ့ တွဲသုံးတဲ့အခါ ပေါင်းစပ်ထားတဲ့ assignment operator 12 ခု ရလာပါတယ်။

ရိုးရိုး assignment operator က တစ်ခုဆိုတော့ စုစုပေါင်းအရေအတွက်က 13 ခုဖြစ်သွားပါတယ်။

ရှေ့သင်ခန်းစာတွေကိုသာ ကျေညက်ခဲ့ရင် 13 ခုလုံးကို  အလိုလို ရပါတယ်။

---

Assignment Operators တွေက precedence သတ်မှတ်ချက်မှာ အဆင့် 14 ဖြစ်ပါတယ်။

---

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=)   (value)
    Identity Operators (is , is not)
    Membership Operators  (in , not in)

10.Logical NOT        --->   not
11.Logical AND        --->   and
12.Logical OR         --->   or
13. Ternary operator    --->  operand_1 if operand_3 else operand_2
14. Assignment operators (=) (13)


e
u
မြှောက် စား
ပေါင်း နှုတ်

shift
and
or နှစ်ခု

C
not
and
or

T
assignment

```

assignment က assignment operator 13 ခု ဖြစ်ပါတယ်။

အတိုကောက်ကို နားလည်ခဲ့မယ်ဆိုရင် precedence 14 ဆင့်နဲ့ operator 42 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

---


## 31. Walrus operator ( := )  (  🦭 )

အာတိတ်က ပင်လယ်ဖျံနဲ့တူလို့ walrus operator လို့ ခေါ်ကြတာဖြစ်ပါတယ်။

__assign and use__ လို့ ဖတ်နိုင်ပါတယ်။

တန်ဖိုးတွေကို အသုံးပြုနေရင်းနဲ့ တစ်ခါတည်း assign လုပ်သွားတာမျိုးပါ။

အသေးစိတ်ကို list comprehension သင်တဲ့အခါ ရှင်းပြပေးပါ့မယ်။

---

precedence သတ်မှတ်ချက်မှာ အဆင့် 15 ဖြစ်ပါတယ်။

---

ပြန်ပေါင်းလိုက်ရင် ခုလိုရပါမယ်။

```

1. Exponentiation ( **  )
2. Unary Operators (+, -, ~) (positive, negative, bitwise NOT)
3. Multiplication, Division, Modulus, Floor Division (*, /, %, //)
4. Addition and Subtraction (+, -)

5. Bitwise Shift Operators  (<<, >>)
6. Bitwise AND (&)    all
7. Bitwise XOR (^)    only any
8. Bitwise OR (|)        any

9. Comparison Operators (==, !=, >, <, >=, <=)   (value)
    Identity Operators (is , is not)
    Membership Operators  (in , not in)

10.Logical NOT        --->   not
11.Logical AND        --->   and
12.Logical OR         --->   or
13. Ternary operator    --->  operand_1 if operand_3 else operand_2
14. Assignment operators (=) (13)
15. Walrus operator (:=)


e
u
မြှောက် စား
ပေါင်း နှုတ်

shift
and
or နှစ်ခု

C
not
and
or

T
assignment
walrus

```

walrus က walrus operator ဖြစ်ပါတယ်။

အတိုကောက်ကို နားလည်ခဲ့မယ်ဆိုရင် precedence 15 ဆင့်နဲ့ operator 43 ခုကို အလွတ်ရသွားမှာ ဖြစ်ပါတယ်။

matrix multiplication (@) လိုမျိုး တစ်ခြား operator တွေလည်း ကျန်သေးပေမယ့် built-in operator တွေကတော့ ဒီ 43 ခုပဲ ရှိပါမယ်။

operator 43 ခုလုံးရဲ့ precedence 15 ဆင့် ကို ရှင်းပြလို့ ပြီးပါပြီ။

နောက်သင်ခန်းစာမှာတော့ associativity ကို ရှင်းပြပေးပါ့မယ်။

---


## 32. Associativity အနှစ်ချုပ်

Precedence မှာ အဆင့် 15 ဆင့် ရှိပေမယ့် Associativity မှာတော့ left sided bind နဲ့ right sided bind ဆိုပြီး နှစ်ခုပဲ ရှိပါတယ်။

operator 43 ခုမှာ 19 မျိုးက right sided bind ဖြစ်ပြီး ကျန်တာကတော့ left sided bind ဖြစ်ပါတယ်။

မှတ်ရလွယ်တဲ့ right sided bind ကိုပဲ မှတ်ထားလိုက်ပါ။

ဒါဆိုရင် 43 ခုလုံးရဲ့ associativity ကို သိသွားပါပြီ။

---

exponent တစ်ခု ၊ assignment operator 13 ခု ၊ walrus operator တစ်ခုနဲ့ unary operator လေးခု ဒီ 19 မျိုးက right sided bind ဖြစ်ကြပါတယ်။

walrus operator က Python 3.8 မှ အသစ်ထွက်တာဖြစ်သလို့ သုံးလေ့သုံးထ မရှိပါဘူး။ unary operator တွေကလည်း နှစ်ခုထပ်တာ ရှားပါတယ်။ unary plus နဲ့ unary minus ဆိုရင် operation လုပ်ပေးတာမဟုတ်ပဲ positive နဲ့ negative သတ်မှတ်ရုံသာဖြစ်လို့ တစ်ချို့တွေက operator စာရင်းထဲတောင် မထည့်ကြပါဘူး။

ဒါကြောင့် __exponent နဲ့ assignment__ နှစ်ခုပဲ မှတ်ထားလိုက်ရင် အဆင်ပြေပါပြီ။

operator မဟုတ်တဲ့ lambda expression ကိုပါ ထည့်တွက်ရင်တော့ အခု 20 ပေါ့။

function သင်ခန်းစာရောက်မှပဲ သင်ရမှာဖြစ်ပါတယ်။

---

#### right sided bind (20)   ( **, = )

1. Exponent (1)

2. Assignment Operators (13)

3. Walrus Operator (1)

4. unary (4)

5. lambda expression (1)

---

#### left sided bind (30)

left sided bind မှာဆိုရင်လည်း built-in operator က __24__ ခုရှိပြီး built-in operator မဟုတ်တဲ့ matrix multiplication `@` ကိုပါ ထည့်တွက်ရင် 25 ခုဖြစ်ပါမယ်။

operator မဟုတ်တဲ့ ဒီငါးခုကလည်း left sided bind ဖြစ်လို့ __30__ ဖြစ်သွားပါမယ်။

1. comma ( tuple packing / unpacking )

2. colon ( slicing )

3. [] (indexing)

4. () (function call)

5. dot(attribute access)

တကယ်တော့ right sided bind ဖြစ်တဲ့ exponent နဲ့ assignment ပဲ မှတ်ထားပါ။

ကျန်တာတွေကတော့ သင်ရင်းနဲ့ သိလာပါလိမ့်မယ်။

---

OOP သင်ပြီး‌ရင်လည်း ပိုနားလည်ဖို့ operator တွေကို ကိုယ်တိုင်ဖန်တီးကြပါမယ်။

control flow နဲ့ function သင်ပြီးရင်တော့ OOP ရောက်ပါပြီ။

Operator သင်ခန်းစာကိုတော့ ဒီမှာပဲ ရပ်လိုက်ပြီး operator စာအုပ်မှပဲ အသေးစိတ်ထပ်ရေးပေးပါ့မယ်။

ရေးတဲ့အဆင့်ကို မရောက်တော့မှာ စိုးလို့ပါ။

အသိပေးချင်တာက data type နဲ့ control flow ကို ပိုင်မှသာ function တွေ ရေးနိုင်မှာပါ။

ဒါမှသာ လက်ရှိသင်နေတဲ့ procedural programming ကို လေ့ကျင့်လို့ ရပါမယ်။

---

procedural programming ကို များများလေ့ကျင့်ရင်း ရေးနိုင်ပြီဆိုမှသာ OOP ကို ဆက်ပြီး သင်လို့ ရပါမယ်။

ဘာကြောင့်လဲဆိုတော့ OOP မှာက သင်ရမှာ မဟုတ်တော့ပဲ ဖန်တီးကြရမှာဖြစ်လို့ပါ။

OOP နဲ့ ကိုယ်တိုင်ဖန်တီးနိုင်မှသာ Python ကို နားလည်မှာပါ။

အားလုံးက ရှေ့ဆုံးနှစ်ခုနဲ့ ချိတ်ဆက်နေကြတာဖြစ်လို့ အစောပိုင်းသင်ခါစမှာ သေချာလေး အားထည့်ပါ။

---

## 33. Sequence

တိုက်ရိုက်ဘာသာပြန်ရင် အစီအစဉ်လို့ အဓိပ္ပါယ်ရပါတယ်။

program တွေ မရေးခင်မှာ ပထမဆုံးအနေနဲ့ Python ရဲ့ ဘာသာပြန်တဲ့ အစီအစဉ်သုံးခုကို သိထားရပါမယ်။


##### 1. Top to Bottom

အပေါ်ကနေ အောက်ကို တစ်ကြောင်းချင်း ဘာသာပြန်ပေးပါတယ်။

မြင်သာအောင် ပြောရရင် __ကွန်ပြူတာဖွင့်တဲ့ program__ ဟာ p0 ဖြစ်ပြီး __သီချင်းဖွင့်တဲ့ program__ ဟာ p1 ဖြစ်တယ်ဆိုပါစို့။

ကွန်ပြူတာကို အရင်ဖွင့်ပြီးမှ သီချင်းဖွင့်စေချင်ရင်

```

p0
p1

```

ဆိုပြီး အရင်ဆုံး အလုပ်လုပ်စေချင်တာကို အပေါ်ဆုံးမှာ ထားပေးရပါမယ်။


##### 2. Left to Right

ဘယ်မှညာ ဘာသာပြန်ပေးပါတယ်။

ကွန်ပြူတာကို အရင်ဖွင့်ပြီးမှ သီချင်းဖွင့်စေချင်ရင်

`p0   p1`  

ဆိုပြီး အရင်ဆုံး အလုပ်လုပ်စေချင်တာကို ဘယ်ဘက်ဆုံးမှာ ထားပေးရပါမယ်။


##### 3. Inner parentheses first

အတွင်းဘက်အကျဆုံး ဝိုက်ကွင်းကို အရင်ဆုံး ဘာသာပြန်ပေးပါတယ်။

ကွန်ပြူတာကိုအရင်ဖွင့်ပြီးမှ သီချင်းဖွင့်စေချင်ရင်

`p1(p0)`  

ဆိုပြီး အရင်ဆုံး အလုပ်လုပ်စေချင်တာကို အတွင်းဘက်အကျဆုံး ဝိုက်ကွင်းထဲမှာ ထားပေးရပါမယ်။

---

__Exercise__ အနေနဲ့

ကွန်ပြူတာဖွင့်တဲ့ program က p0

သီချင်းဖွင့်တဲ့ program က p1

သီချင်းပိတ်တဲ့ program က p2

ကွန်ပြူတာပိတ်တဲ့ program က p3

အစရှိသဖြင့် program လေးခုရှိတယ်ဆိုပါစို့။

---

ပထမဆုံး ကွန်ပြူတာကို ဖွင့်မယ်။

ဒုတိယအနေနဲ့ သီချင်းကို ဖွင့်မယ်။

တတိယအနေနဲ့ သီချင်းကို ပိတ်မယ်။

စတုတ္ထအနေနဲ့ ကွန်ပြုတာကို ပိတ်မယ်။

1. ဒါကို Top to Bottom sequence နဲ့ ရေးပါ။

2. Left to Right sequence နဲ့ ရေးပါ။

3. Inner parentheses first sequence နဲ့ ရေးပါ။


---






## 24. Bitwise operators (6)
## 25. Comparison Operators (==, !=, >, <, >=, <=) (value)
## 26. Identity Operators (is, is not) (memory address)
## 27. Membership Operators ( in , not in )
## 28. Logical Operators
## 29. Ternary operator
## 30. Assignment Operators ( = )
## 31. Walrus operator ( := )  (  🦭 )
## 32. Associativity အနှစ်ချုပ်
## 33. Sequence


```python

```


```python

```
